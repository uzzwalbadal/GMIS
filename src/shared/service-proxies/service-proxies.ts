/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.7.0 (NJsonSchema v9.13.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class AgricultreInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getAgricultureInfoByProjectId(projectId: string | null | undefined): Observable<Dto_AgricultreInfoDetailModel[]> {
        let url_ = this.baseUrl + "/api/services/app/AgricultreInfo/GetAgricultureInfoByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgricultureInfoByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgricultureInfoByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultreInfoDetailModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultreInfoDetailModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgricultureInfoByProjectId(response: HttpResponseBase): Observable<Dto_AgricultreInfoDetailModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_AgricultreInfoDetailModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultreInfoDetailModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCropNameList(): Observable<Dto_CropName[]> {
        let url_ = this.baseUrl + "/api/services/app/AgricultreInfo/GetCropNameList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCropNameList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCropNameList(<any>response_);
                } catch (e) {
                    return <Observable<Dto_CropName[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_CropName[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCropNameList(response: HttpResponseBase): Observable<Dto_CropName[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_CropName.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_CropName[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_AgricultreInfo | null | undefined): Observable<Dto_AgricultreInfo> {
        let url_ = this.baseUrl + "/api/services/app/AgricultreInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultreInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultreInfo>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_AgricultreInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_AgricultreInfo.fromJS(resultData200) : new Dto_AgricultreInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultreInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_AgricultreInfo | null | undefined): Observable<Dto_AgricultreInfo> {
        let url_ = this.baseUrl + "/api/services/app/AgricultreInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultreInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultreInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_AgricultreInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_AgricultreInfo.fromJS(resultData200) : new Dto_AgricultreInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultreInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AgricultreInfo/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_AgricultreInfo> {
        let url_ = this.baseUrl + "/api/services/app/AgricultreInfo/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultreInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultreInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_AgricultreInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_AgricultreInfo.fromJS(resultData200) : new Dto_AgricultreInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultreInfo>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_AgricultreInfo> {
        let url_ = this.baseUrl + "/api/services/app/AgricultreInfo/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_AgricultreInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_AgricultreInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_AgricultreInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_AgricultreInfo.fromJS(resultData200) : new PagedResultDtoOfDto_AgricultreInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_AgricultreInfo>(<any>null);
    }
}

@Injectable()
export class AgricultureDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getAgricultureDetailByProjectId(projectId: string | null | undefined): Observable<Dto_AgricultureDetail> {
        let url_ = this.baseUrl + "/api/services/app/AgricultureDetail/GetAgricultureDetailByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgricultureDetailByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgricultureDetailByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultureDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultureDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgricultureDetailByProjectId(response: HttpResponseBase): Observable<Dto_AgricultureDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_AgricultureDetail.fromJS(resultData200) : new Dto_AgricultureDetail();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultureDetail>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_AgricultureDetail | null | undefined): Observable<Dto_AgricultureDetail> {
        let url_ = this.baseUrl + "/api/services/app/AgricultureDetail/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultureDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultureDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_AgricultureDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_AgricultureDetail.fromJS(resultData200) : new Dto_AgricultureDetail();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultureDetail>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_AgricultureDetail | null | undefined): Observable<Dto_AgricultureDetail> {
        let url_ = this.baseUrl + "/api/services/app/AgricultureDetail/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultureDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultureDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_AgricultureDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_AgricultureDetail.fromJS(resultData200) : new Dto_AgricultureDetail();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultureDetail>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AgricultureDetail/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_AgricultureDetail> {
        let url_ = this.baseUrl + "/api/services/app/AgricultureDetail/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_AgricultureDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_AgricultureDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_AgricultureDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_AgricultureDetail.fromJS(resultData200) : new Dto_AgricultureDetail();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_AgricultureDetail>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_AgricultureDetail> {
        let url_ = this.baseUrl + "/api/services/app/AgricultureDetail/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_AgricultureDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_AgricultureDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_AgricultureDetail> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_AgricultureDetail.fromJS(resultData200) : new PagedResultDtoOfDto_AgricultureDetail();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_AgricultureDetail>(<any>null);
    }
}

@Injectable()
export class BranchCanalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param mainCanalId (optional) 
     * @return Success
     */
    getBranchCanalByMainCanalId(mainCanalId: number | null | undefined): Observable<Dto_BranchCanal[]> {
        let url_ = this.baseUrl + "/api/services/app/BranchCanal/GetBranchCanalByMainCanalId?";
        if (mainCanalId !== undefined)
            url_ += "MainCanalId=" + encodeURIComponent("" + mainCanalId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBranchCanalByMainCanalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBranchCanalByMainCanalId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_BranchCanal[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_BranchCanal[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBranchCanalByMainCanalId(response: HttpResponseBase): Observable<Dto_BranchCanal[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_BranchCanal.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_BranchCanal[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_BranchCanal | null | undefined): Observable<Dto_BranchCanal> {
        let url_ = this.baseUrl + "/api/services/app/BranchCanal/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_BranchCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_BranchCanal>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_BranchCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_BranchCanal.fromJS(resultData200) : new Dto_BranchCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_BranchCanal>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_BranchCanal | null | undefined): Observable<Dto_BranchCanal> {
        let url_ = this.baseUrl + "/api/services/app/BranchCanal/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_BranchCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_BranchCanal>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_BranchCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_BranchCanal.fromJS(resultData200) : new Dto_BranchCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_BranchCanal>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BranchCanal/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_BranchCanal> {
        let url_ = this.baseUrl + "/api/services/app/BranchCanal/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_BranchCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_BranchCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_BranchCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_BranchCanal.fromJS(resultData200) : new Dto_BranchCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_BranchCanal>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_BranchCanal> {
        let url_ = this.baseUrl + "/api/services/app/BranchCanal/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_BranchCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_BranchCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_BranchCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_BranchCanal.fromJS(resultData200) : new PagedResultDtoOfDto_BranchCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_BranchCanal>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContractManagementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getContractManagementDetailByProjectId(projectId: string | null | undefined): Observable<Dto_ContractManagement> {
        let url_ = this.baseUrl + "/api/services/app/ContractManagement/GetContractManagementDetailByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContractManagementDetailByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContractManagementDetailByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ContractManagement>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ContractManagement>><any>_observableThrow(response_);
        }));
    }

    protected processGetContractManagementDetailByProjectId(response: HttpResponseBase): Observable<Dto_ContractManagement> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ContractManagement.fromJS(resultData200) : new Dto_ContractManagement();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ContractManagement>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_ContractManagement | null | undefined): Observable<Dto_ContractManagement> {
        let url_ = this.baseUrl + "/api/services/app/ContractManagement/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ContractManagement>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ContractManagement>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_ContractManagement> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ContractManagement.fromJS(resultData200) : new Dto_ContractManagement();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ContractManagement>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_ContractManagement> {
        let url_ = this.baseUrl + "/api/services/app/ContractManagement/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ContractManagement>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ContractManagement>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_ContractManagement> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ContractManagement.fromJS(resultData200) : new Dto_ContractManagement();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ContractManagement>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_ContractManagement> {
        let url_ = this.baseUrl + "/api/services/app/ContractManagement/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_ContractManagement>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_ContractManagement>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_ContractManagement> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_ContractManagement.fromJS(resultData200) : new PagedResultDtoOfDto_ContractManagement();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_ContractManagement>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_ContractManagement | null | undefined): Observable<Dto_ContractManagement> {
        let url_ = this.baseUrl + "/api/services/app/ContractManagement/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ContractManagement>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ContractManagement>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_ContractManagement> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ContractManagement.fromJS(resultData200) : new Dto_ContractManagement();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ContractManagement>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ContractManagement/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CropNameServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_CropName> {
        let url_ = this.baseUrl + "/api/services/app/CropName/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_CropName>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_CropName>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_CropName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_CropName.fromJS(resultData200) : new Dto_CropName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_CropName>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_CropName> {
        let url_ = this.baseUrl + "/api/services/app/CropName/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_CropName>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_CropName>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_CropName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_CropName.fromJS(resultData200) : new PagedResultDtoOfDto_CropName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_CropName>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_CropName | null | undefined): Observable<Dto_CropName> {
        let url_ = this.baseUrl + "/api/services/app/CropName/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_CropName>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_CropName>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_CropName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_CropName.fromJS(resultData200) : new Dto_CropName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_CropName>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_CropName | null | undefined): Observable<Dto_CropName> {
        let url_ = this.baseUrl + "/api/services/app/CropName/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_CropName>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_CropName>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_CropName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_CropName.fromJS(resultData200) : new Dto_CropName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_CropName>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CropName/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DistrictServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param provienceId (optional) 
     * @return Success
     */
    getDistrictFromProvienceId(provienceId: number | null | undefined): Observable<Dto_LocationDistrict[]> {
        let url_ = this.baseUrl + "/api/services/app/District/GetDistrictFromProvienceId?";
        if (provienceId !== undefined)
            url_ += "ProvienceId=" + encodeURIComponent("" + provienceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistrictFromProvienceId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistrictFromProvienceId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationDistrict[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationDistrict[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDistrictFromProvienceId(response: HttpResponseBase): Observable<Dto_LocationDistrict[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_LocationDistrict.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationDistrict[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_LocationDistrict> {
        let url_ = this.baseUrl + "/api/services/app/District/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationDistrict>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationDistrict>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_LocationDistrict> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationDistrict.fromJS(resultData200) : new Dto_LocationDistrict();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationDistrict>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDto_LocationDistrict> {
        let url_ = this.baseUrl + "/api/services/app/District/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_LocationDistrict>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_LocationDistrict>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_LocationDistrict> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_LocationDistrict.fromJS(resultData200) : new PagedResultDtoOfDto_LocationDistrict();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_LocationDistrict>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_LocationDistrict | null | undefined): Observable<Dto_LocationDistrict> {
        let url_ = this.baseUrl + "/api/services/app/District/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationDistrict>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationDistrict>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_LocationDistrict> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationDistrict.fromJS(resultData200) : new Dto_LocationDistrict();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationDistrict>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_LocationDistrict | null | undefined): Observable<Dto_LocationDistrict> {
        let url_ = this.baseUrl + "/api/services/app/District/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationDistrict>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationDistrict>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_LocationDistrict> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationDistrict.fromJS(resultData200) : new Dto_LocationDistrict();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationDistrict>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/District/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DocumentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    uploadDocument(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Document/UploadDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDocument(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUploadDocument(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @param docType (optional) 
     * @return Success
     */
    getDocumentListByProjectidAndDocType(projectId: string | null | undefined, docType: number | null | undefined): Observable<ListResultDtoOfDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetDocumentListByProjectidAndDocType?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        if (docType !== undefined)
            url_ += "DocType=" + encodeURIComponent("" + docType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentListByProjectidAndDocType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentListByProjectidAndDocType(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentListByProjectidAndDocType(response: HttpResponseBase): Observable<ListResultDtoOfDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentDto.fromJS(resultData200) : new ListResultDtoOfDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentDto>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getDocumentListByProjectid(projectId: string | null | undefined): Observable<ListResultDtoOfDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetDocumentListByProjectid?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentListByProjectid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentListByProjectid(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentListByProjectid(response: HttpResponseBase): Observable<ListResultDtoOfDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDocumentDto.fromJS(resultData200) : new ListResultDtoOfDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDocumentDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateDocumentDto | null | undefined): Observable<DocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentDto.fromJS(resultData200) : new DocumentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: DocumentDto | null | undefined): Observable<DocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentDto.fromJS(resultData200) : new DocumentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Document/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<DocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DocumentDto.fromJS(resultData200) : new DocumentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentDto>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDocumentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDocumentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDocumentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDocumentDto.fromJS(resultData200) : new PagedResultDtoOfDocumentDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDocumentDto>(<any>null);
    }
}

@Injectable()
export class EconomicInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getEconomicInfoListByProjectId(projectId: string | null | undefined): Observable<Dto_EconomicInfo[]> {
        let url_ = this.baseUrl + "/api/services/app/EconomicInformation/GetEconomicInfoListByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEconomicInfoListByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEconomicInfoListByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_EconomicInfo[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_EconomicInfo[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEconomicInfoListByProjectId(response: HttpResponseBase): Observable<Dto_EconomicInfo[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_EconomicInfo.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_EconomicInfo[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_EconomicInfo | null | undefined): Observable<Dto_EconomicInfo> {
        let url_ = this.baseUrl + "/api/services/app/EconomicInformation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_EconomicInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_EconomicInfo>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_EconomicInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_EconomicInfo.fromJS(resultData200) : new Dto_EconomicInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_EconomicInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_EconomicInfo | null | undefined): Observable<Dto_EconomicInfo> {
        let url_ = this.baseUrl + "/api/services/app/EconomicInformation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_EconomicInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_EconomicInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_EconomicInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_EconomicInfo.fromJS(resultData200) : new Dto_EconomicInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_EconomicInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EconomicInformation/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_EconomicInfo> {
        let url_ = this.baseUrl + "/api/services/app/EconomicInformation/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_EconomicInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_EconomicInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_EconomicInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_EconomicInfo.fromJS(resultData200) : new Dto_EconomicInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_EconomicInfo>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_EconomicInfo> {
        let url_ = this.baseUrl + "/api/services/app/EconomicInformation/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_EconomicInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_EconomicInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_EconomicInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_EconomicInfo.fromJS(resultData200) : new PagedResultDtoOfDto_EconomicInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_EconomicInfo>(<any>null);
    }
}

@Injectable()
export class EmbankmentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getEmbankmentByProjectId(projectId: string | null | undefined): Observable<Dto_Embankment[]> {
        let url_ = this.baseUrl + "/api/services/app/Embankment/GetEmbankmentByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmbankmentByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmbankmentByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Embankment[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Embankment[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEmbankmentByProjectId(response: HttpResponseBase): Observable<Dto_Embankment[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_Embankment.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Embankment[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_Embankment | null | undefined): Observable<Dto_Embankment> {
        let url_ = this.baseUrl + "/api/services/app/Embankment/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Embankment>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Embankment>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_Embankment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Embankment.fromJS(resultData200) : new Dto_Embankment();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Embankment>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_Embankment | null | undefined): Observable<Dto_Embankment> {
        let url_ = this.baseUrl + "/api/services/app/Embankment/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Embankment>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Embankment>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_Embankment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Embankment.fromJS(resultData200) : new Dto_Embankment();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Embankment>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Embankment/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_Embankment> {
        let url_ = this.baseUrl + "/api/services/app/Embankment/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Embankment>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Embankment>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_Embankment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Embankment.fromJS(resultData200) : new Dto_Embankment();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Embankment>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_Embankment> {
        let url_ = this.baseUrl + "/api/services/app/Embankment/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_Embankment>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_Embankment>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_Embankment> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_Embankment.fromJS(resultData200) : new PagedResultDtoOfDto_Embankment();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_Embankment>(<any>null);
    }
}

@Injectable()
export class EthicInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_EthicsInformation> {
        let url_ = this.baseUrl + "/api/services/app/EthicInformation/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_EthicsInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_EthicsInformation>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_EthicsInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_EthicsInformation.fromJS(resultData200) : new PagedResultDtoOfDto_EthicsInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_EthicsInformation>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_EthicsInformation | null | undefined): Observable<Dto_EthicsInformation> {
        let url_ = this.baseUrl + "/api/services/app/EthicInformation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_EthicsInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_EthicsInformation>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_EthicsInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_EthicsInformation.fromJS(resultData200) : new Dto_EthicsInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_EthicsInformation>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_EthicsInformation | null | undefined): Observable<Dto_EthicsInformation> {
        let url_ = this.baseUrl + "/api/services/app/EthicInformation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_EthicsInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_EthicsInformation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_EthicsInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_EthicsInformation.fromJS(resultData200) : new Dto_EthicsInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_EthicsInformation>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EthicInformation/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_EthicsInformation> {
        let url_ = this.baseUrl + "/api/services/app/EthicInformation/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_EthicsInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_EthicsInformation>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_EthicsInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_EthicsInformation.fromJS(resultData200) : new Dto_EthicsInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_EthicsInformation>(<any>null);
    }
}

@Injectable()
export class GraphDataServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param iType (optional) 
     * @return Success
     */
    getGraphDataByIType(iType: number | null | undefined): Observable<Dto_GraphData[]> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/GetGraphDataByIType?";
        if (iType !== undefined)
            url_ += "IType=" + encodeURIComponent("" + iType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGraphDataByIType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGraphDataByIType(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GraphData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GraphData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGraphDataByIType(response: HttpResponseBase): Observable<Dto_GraphData[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_GraphData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GraphData[]>(<any>null);
    }

    /**
     * @return Success
     */
    getProjectCountByProgramType(): Observable<GraphData_Dto_ProcedureCall[]> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/GetProjectCountByProgramType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectCountByProgramType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectCountByProgramType(<any>response_);
                } catch (e) {
                    return <Observable<GraphData_Dto_ProcedureCall[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GraphData_Dto_ProcedureCall[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectCountByProgramType(response: HttpResponseBase): Observable<GraphData_Dto_ProcedureCall[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GraphData_Dto_ProcedureCall.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GraphData_Dto_ProcedureCall[]>(<any>null);
    }

    /**
     * @return Success
     */
    getSumGCACountGroupByProgramTypeAsync(): Observable<GraphData_Dto_ProcedureCall[]> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/GetSumGCACountGroupByProgramTypeAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSumGCACountGroupByProgramTypeAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSumGCACountGroupByProgramTypeAsync(<any>response_);
                } catch (e) {
                    return <Observable<GraphData_Dto_ProcedureCall[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GraphData_Dto_ProcedureCall[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSumGCACountGroupByProgramTypeAsync(response: HttpResponseBase): Observable<GraphData_Dto_ProcedureCall[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GraphData_Dto_ProcedureCall.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GraphData_Dto_ProcedureCall[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_GraphData | null | undefined): Observable<Dto_GraphData> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GraphData>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GraphData>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_GraphData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_GraphData.fromJS(resultData200) : new Dto_GraphData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GraphData>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_GraphData | null | undefined): Observable<Dto_GraphData> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GraphData>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GraphData>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_GraphData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_GraphData.fromJS(resultData200) : new Dto_GraphData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GraphData>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_GraphData> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GraphData>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GraphData>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_GraphData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_GraphData.fromJS(resultData200) : new Dto_GraphData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GraphData>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_GraphData> {
        let url_ = this.baseUrl + "/api/services/app/GraphData/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_GraphData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_GraphData>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_GraphData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_GraphData.fromJS(resultData200) : new PagedResultDtoOfDto_GraphData();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_GraphData>(<any>null);
    }
}

@Injectable()
export class GroundWaterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getGroundWaterInfoListByProjectId(projectId: string | null | undefined): Observable<Dto_GroundWaterInformation[]> {
        let url_ = this.baseUrl + "/api/services/app/GroundWater/GetGroundWaterInfoListByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroundWaterInfoListByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroundWaterInfoListByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GroundWaterInformation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GroundWaterInformation[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroundWaterInfoListByProjectId(response: HttpResponseBase): Observable<Dto_GroundWaterInformation[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_GroundWaterInformation.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GroundWaterInformation[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_GroundWaterInformation | null | undefined): Observable<Dto_GroundWaterInformation> {
        let url_ = this.baseUrl + "/api/services/app/GroundWater/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GroundWaterInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GroundWaterInformation>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_GroundWaterInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_GroundWaterInformation.fromJS(resultData200) : new Dto_GroundWaterInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GroundWaterInformation>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_GroundWaterInformation | null | undefined): Observable<Dto_GroundWaterInformation> {
        let url_ = this.baseUrl + "/api/services/app/GroundWater/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GroundWaterInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GroundWaterInformation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_GroundWaterInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_GroundWaterInformation.fromJS(resultData200) : new Dto_GroundWaterInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GroundWaterInformation>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroundWater/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_GroundWaterInformation> {
        let url_ = this.baseUrl + "/api/services/app/GroundWater/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_GroundWaterInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_GroundWaterInformation>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_GroundWaterInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_GroundWaterInformation.fromJS(resultData200) : new Dto_GroundWaterInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_GroundWaterInformation>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_GroundWaterInformation> {
        let url_ = this.baseUrl + "/api/services/app/GroundWater/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_GroundWaterInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_GroundWaterInformation>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_GroundWaterInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_GroundWaterInformation.fromJS(resultData200) : new PagedResultDtoOfDto_GroundWaterInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_GroundWaterInformation>(<any>null);
    }
}

@Injectable()
export class HeadWorkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getHeadWorksInfoByProjectId(projectId: string | null | undefined): Observable<Dto_HeadWork> {
        let url_ = this.baseUrl + "/api/services/app/HeadWork/GetHeadWorksInfoByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHeadWorksInfoByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHeadWorksInfoByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_HeadWork>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_HeadWork>><any>_observableThrow(response_);
        }));
    }

    protected processGetHeadWorksInfoByProjectId(response: HttpResponseBase): Observable<Dto_HeadWork> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_HeadWork.fromJS(resultData200) : new Dto_HeadWork();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_HeadWork>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_HeadWork | null | undefined): Observable<Dto_HeadWork> {
        let url_ = this.baseUrl + "/api/services/app/HeadWork/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_HeadWork>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_HeadWork>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_HeadWork> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_HeadWork.fromJS(resultData200) : new Dto_HeadWork();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_HeadWork>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_HeadWork | null | undefined): Observable<Dto_HeadWork> {
        let url_ = this.baseUrl + "/api/services/app/HeadWork/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_HeadWork>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_HeadWork>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_HeadWork> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_HeadWork.fromJS(resultData200) : new Dto_HeadWork();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_HeadWork>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HeadWork/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_HeadWork> {
        let url_ = this.baseUrl + "/api/services/app/HeadWork/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_HeadWork>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_HeadWork>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_HeadWork> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_HeadWork.fromJS(resultData200) : new Dto_HeadWork();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_HeadWork>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_HeadWork> {
        let url_ = this.baseUrl + "/api/services/app/HeadWork/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_HeadWork>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_HeadWork>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_HeadWork> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_HeadWork.fromJS(resultData200) : new PagedResultDtoOfDto_HeadWork();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_HeadWork>(<any>null);
    }
}

@Injectable()
export class LocalBodynameServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param districtid (optional) 
     * @return Success
     */
    getLocalBodyTypeFromDistrictId(districtid: number | null | undefined): Observable<Dto_LocalBodyType[]> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyname/GetLocalBodyTypeFromDistrictId?";
        if (districtid !== undefined)
            url_ += "Districtid=" + encodeURIComponent("" + districtid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalBodyTypeFromDistrictId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalBodyTypeFromDistrictId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocalBodyTypeFromDistrictId(response: HttpResponseBase): Observable<Dto_LocalBodyType[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_LocalBodyType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyType[]>(<any>null);
    }

    /**
     * @param districtid (optional) 
     * @param localbodyTypeId (optional) 
     * @return Success
     */
    getLocalBodyNameFromDistrictIdAndLocalBodyType(districtid: number | null | undefined, localbodyTypeId: number | null | undefined): Observable<Dto_LocalBodyName[]> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyname/GetLocalBodyNameFromDistrictIdAndLocalBodyType?";
        if (districtid !== undefined)
            url_ += "Districtid=" + encodeURIComponent("" + districtid) + "&"; 
        if (localbodyTypeId !== undefined)
            url_ += "localbodyTypeId=" + encodeURIComponent("" + localbodyTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalBodyNameFromDistrictIdAndLocalBodyType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalBodyNameFromDistrictIdAndLocalBodyType(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyName[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyName[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocalBodyNameFromDistrictIdAndLocalBodyType(response: HttpResponseBase): Observable<Dto_LocalBodyName[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_LocalBodyName.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyName[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_LocalBodyName> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyname/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyName>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyName>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_LocalBodyName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocalBodyName.fromJS(resultData200) : new Dto_LocalBodyName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyName>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDto_LocalBodyName> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyname/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_LocalBodyName>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_LocalBodyName>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_LocalBodyName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_LocalBodyName.fromJS(resultData200) : new PagedResultDtoOfDto_LocalBodyName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_LocalBodyName>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_LocalBodyName | null | undefined): Observable<Dto_LocalBodyName> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyname/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyName>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyName>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_LocalBodyName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocalBodyName.fromJS(resultData200) : new Dto_LocalBodyName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyName>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_LocalBodyName | null | undefined): Observable<Dto_LocalBodyName> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyname/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyName>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyName>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_LocalBodyName> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocalBodyName.fromJS(resultData200) : new Dto_LocalBodyName();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyName>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyname/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LocalBodyTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDto_LocalBodyType> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyType/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_LocalBodyType>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_LocalBodyType>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_LocalBodyType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_LocalBodyType.fromJS(resultData200) : new PagedResultDtoOfDto_LocalBodyType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_LocalBodyType>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_LocalBodyType> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyType/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyType>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_LocalBodyType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocalBodyType.fromJS(resultData200) : new Dto_LocalBodyType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyType>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_LocalBodyType | null | undefined): Observable<Dto_LocalBodyType> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyType>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_LocalBodyType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocalBodyType.fromJS(resultData200) : new Dto_LocalBodyType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyType>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_LocalBodyType | null | undefined): Observable<Dto_LocalBodyType> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocalBodyType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocalBodyType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_LocalBodyType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocalBodyType.fromJS(resultData200) : new Dto_LocalBodyType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocalBodyType>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LocalBodyType/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LocationWardRelationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createProjectWardRelation(input: Dto_LocationProjectRelation[] | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/LocationWardRelation/CreateProjectWardRelation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProjectWardRelation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProjectWardRelation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProjectWardRelation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getAllProjectRelation(projectId: string | null | undefined): Observable<LocationProjectWardRelationDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/LocationWardRelation/GetAllProjectRelation?";
        if (projectId !== undefined)
            url_ += "ProjectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectRelation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectRelation(<any>response_);
                } catch (e) {
                    return <Observable<LocationProjectWardRelationDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LocationProjectWardRelationDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectRelation(response: HttpResponseBase): Observable<LocationProjectWardRelationDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LocationProjectWardRelationDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LocationProjectWardRelationDetailDto[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_LocationProjectRelation | null | undefined): Observable<Dto_LocationProjectRelation> {
        let url_ = this.baseUrl + "/api/services/app/LocationWardRelation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationProjectRelation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationProjectRelation>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_LocationProjectRelation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationProjectRelation.fromJS(resultData200) : new Dto_LocationProjectRelation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationProjectRelation>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LocationWardRelation/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_LocationProjectRelation | null | undefined): Observable<Dto_LocationProjectRelation> {
        let url_ = this.baseUrl + "/api/services/app/LocationWardRelation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationProjectRelation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationProjectRelation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_LocationProjectRelation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationProjectRelation.fromJS(resultData200) : new Dto_LocationProjectRelation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationProjectRelation>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_LocationProjectRelation> {
        let url_ = this.baseUrl + "/api/services/app/LocationWardRelation/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationProjectRelation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationProjectRelation>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_LocationProjectRelation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationProjectRelation.fromJS(resultData200) : new Dto_LocationProjectRelation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationProjectRelation>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_LocationProjectRelation> {
        let url_ = this.baseUrl + "/api/services/app/LocationWardRelation/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_LocationProjectRelation>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_LocationProjectRelation>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_LocationProjectRelation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_LocationProjectRelation.fromJS(resultData200) : new PagedResultDtoOfDto_LocationProjectRelation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_LocationProjectRelation>(<any>null);
    }
}

@Injectable()
export class MainCanalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getMainCanalInfoByProjectId(projectId: string | null | undefined): Observable<MainCanalViewModel[]> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/GetMainCanalInfoByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainCanalInfoByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainCanalInfoByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<MainCanalViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MainCanalViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMainCanalInfoByProjectId(response: HttpResponseBase): Observable<MainCanalViewModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MainCanalViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainCanalViewModel[]>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @param isCanalDirectionLeft (optional) 
     * @return Success
     */
    getMainCanalInfoByProjectIdNCanalDirection(projectId: string | null | undefined, isCanalDirectionLeft: boolean | null | undefined): Observable<MainCanalViewModel> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/GetMainCanalInfoByProjectIdNCanalDirection?";
        if (projectId !== undefined)
            url_ += "ProjectId=" + encodeURIComponent("" + projectId) + "&"; 
        if (isCanalDirectionLeft !== undefined)
            url_ += "IsCanalDirectionLeft=" + encodeURIComponent("" + isCanalDirectionLeft) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMainCanalInfoByProjectIdNCanalDirection(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMainCanalInfoByProjectIdNCanalDirection(<any>response_);
                } catch (e) {
                    return <Observable<MainCanalViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MainCanalViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetMainCanalInfoByProjectIdNCanalDirection(response: HttpResponseBase): Observable<MainCanalViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MainCanalViewModel.fromJS(resultData200) : new MainCanalViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainCanalViewModel>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    mainCanalData(input: MainCanalDataModel | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/MainCanalData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMainCanalData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMainCanalData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMainCanalData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_MainCanal | null | undefined): Observable<Dto_MainCanal> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_MainCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_MainCanal>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_MainCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_MainCanal.fromJS(resultData200) : new Dto_MainCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_MainCanal>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_MainCanal | null | undefined): Observable<Dto_MainCanal> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_MainCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_MainCanal>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_MainCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_MainCanal.fromJS(resultData200) : new Dto_MainCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_MainCanal>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_MainCanal> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_MainCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_MainCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_MainCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_MainCanal.fromJS(resultData200) : new Dto_MainCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_MainCanal>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_MainCanal> {
        let url_ = this.baseUrl + "/api/services/app/MainCanal/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_MainCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_MainCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_MainCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_MainCanal.fromJS(resultData200) : new PagedResultDtoOfDto_MainCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_MainCanal>(<any>null);
    }
}

@Injectable()
export class MainCanalStructureTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_MainCanalStructureType> {
        let url_ = this.baseUrl + "/api/services/app/MainCanalStructureType/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_MainCanalStructureType>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_MainCanalStructureType>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_MainCanalStructureType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_MainCanalStructureType.fromJS(resultData200) : new PagedResultDtoOfDto_MainCanalStructureType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_MainCanalStructureType>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_MainCanalStructureType> {
        let url_ = this.baseUrl + "/api/services/app/MainCanalStructureType/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_MainCanalStructureType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_MainCanalStructureType>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_MainCanalStructureType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_MainCanalStructureType.fromJS(resultData200) : new Dto_MainCanalStructureType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_MainCanalStructureType>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_MainCanalStructureType | null | undefined): Observable<Dto_MainCanalStructureType> {
        let url_ = this.baseUrl + "/api/services/app/MainCanalStructureType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_MainCanalStructureType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_MainCanalStructureType>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_MainCanalStructureType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_MainCanalStructureType.fromJS(resultData200) : new Dto_MainCanalStructureType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_MainCanalStructureType>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_MainCanalStructureType | null | undefined): Observable<Dto_MainCanalStructureType> {
        let url_ = this.baseUrl + "/api/services/app/MainCanalStructureType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_MainCanalStructureType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_MainCanalStructureType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_MainCanalStructureType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_MainCanalStructureType.fromJS(resultData200) : new Dto_MainCanalStructureType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_MainCanalStructureType>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MainCanalStructureType/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProgramInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_ProgramInformation> {
        let url_ = this.baseUrl + "/api/services/app/ProgramInfo/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProgramInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProgramInformation>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_ProgramInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProgramInformation.fromJS(resultData200) : new Dto_ProgramInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProgramInformation>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_ProgramInformation> {
        let url_ = this.baseUrl + "/api/services/app/ProgramInfo/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_ProgramInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_ProgramInformation>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_ProgramInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_ProgramInformation.fromJS(resultData200) : new PagedResultDtoOfDto_ProgramInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_ProgramInformation>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_ProgramInformation | null | undefined): Observable<Dto_ProgramInformation> {
        let url_ = this.baseUrl + "/api/services/app/ProgramInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProgramInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProgramInformation>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_ProgramInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProgramInformation.fromJS(resultData200) : new Dto_ProgramInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProgramInformation>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_ProgramInformation | null | undefined): Observable<Dto_ProgramInformation> {
        let url_ = this.baseUrl + "/api/services/app/ProgramInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProgramInformation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProgramInformation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_ProgramInformation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProgramInformation.fromJS(resultData200) : new Dto_ProgramInformation();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProgramInformation>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProgramInfo/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProgramTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_ProgramType> {
        let url_ = this.baseUrl + "/api/services/app/ProgramType/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProgramType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProgramType>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_ProgramType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProgramType.fromJS(resultData200) : new Dto_ProgramType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProgramType>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_ProgramType> {
        let url_ = this.baseUrl + "/api/services/app/ProgramType/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_ProgramType>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_ProgramType>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_ProgramType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_ProgramType.fromJS(resultData200) : new PagedResultDtoOfDto_ProgramType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_ProgramType>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_ProgramType | null | undefined): Observable<Dto_ProgramType> {
        let url_ = this.baseUrl + "/api/services/app/ProgramType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProgramType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProgramType>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_ProgramType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProgramType.fromJS(resultData200) : new Dto_ProgramType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProgramType>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_ProgramType | null | undefined): Observable<Dto_ProgramType> {
        let url_ = this.baseUrl + "/api/services/app/ProgramType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProgramType>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProgramType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_ProgramType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProgramType.fromJS(resultData200) : new Dto_ProgramType();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProgramType>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProgramType/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDto_Project> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_Project>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_Project>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_Project> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_Project.fromJS(resultData200) : new PagedResultDtoOfDto_Project();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_Project>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllWithUserCount(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_ProjectUserCount> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetAllWithUserCount?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithUserCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithUserCount(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_ProjectUserCount>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_ProjectUserCount>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWithUserCount(response: HttpResponseBase): Observable<PagedResultDtoOfDto_ProjectUserCount> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_ProjectUserCount.fromJS(resultData200) : new PagedResultDtoOfDto_ProjectUserCount();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_ProjectUserCount>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_Project | null | undefined): Observable<Dto_Project> {
        let url_ = this.baseUrl + "/api/services/app/Project/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Project>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Project>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_Project> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Project.fromJS(resultData200) : new Dto_Project();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Project>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getProjectsInDasboard(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_UserProjectViewModel> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetProjectsInDasboard?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectsInDasboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectsInDasboard(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_UserProjectViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_UserProjectViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectsInDasboard(response: HttpResponseBase): Observable<PagedResultDtoOfDto_UserProjectViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_UserProjectViewModel.fromJS(resultData200) : new PagedResultDtoOfDto_UserProjectViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_UserProjectViewModel>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllProjectUser(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<ListResultDtoOfDto_UserProjectViewModel> {
        let url_ = this.baseUrl + "/api/services/app/Project/GetAllProjectUser?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectUser(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfDto_UserProjectViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfDto_UserProjectViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectUser(response: HttpResponseBase): Observable<ListResultDtoOfDto_UserProjectViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfDto_UserProjectViewModel.fromJS(resultData200) : new ListResultDtoOfDto_UserProjectViewModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfDto_UserProjectViewModel>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    validateUserAndProjectId(projectId: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Project/ValidateUserAndProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateUserAndProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateUserAndProjectId(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateUserAndProjectId(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_Project | null | undefined): Observable<Dto_Project> {
        let url_ = this.baseUrl + "/api/services/app/Project/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Project>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Project>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_Project> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Project.fromJS(resultData200) : new Dto_Project();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Project>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Project/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<Dto_Project> {
        let url_ = this.baseUrl + "/api/services/app/Project/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Project>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Project>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_Project> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Project.fromJS(resultData200) : new Dto_Project();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Project>(<any>null);
    }
}

@Injectable()
export class ProjectInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_ProjectInfo | null | undefined): Observable<Dto_ProjectInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInformation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProjectInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProjectInfo>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_ProjectInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProjectInfo.fromJS(resultData200) : new Dto_ProjectInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProjectInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_ProjectInfo | null | undefined): Observable<Dto_ProjectInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInformation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProjectInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProjectInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_ProjectInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProjectInfo.fromJS(resultData200) : new Dto_ProjectInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProjectInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getProjectInformationByProjectId(input: string | null | undefined): Observable<Dto_ProjectInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInformation/GetProjectInformationByProjectId?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectInformationByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectInformationByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProjectInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProjectInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectInformationByProjectId(response: HttpResponseBase): Observable<Dto_ProjectInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProjectInfo.fromJS(resultData200) : new Dto_ProjectInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProjectInfo>(<any>null);
    }

    /**
     * @return Success
     */
    getAllProjectInfosInitials(): Observable<ProjectInformationInitals> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInformation/GetAllProjectInfosInitials";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectInfosInitials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectInfosInitials(<any>response_);
                } catch (e) {
                    return <Observable<ProjectInformationInitals>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectInformationInitals>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectInfosInitials(response: HttpResponseBase): Observable<ProjectInformationInitals> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProjectInformationInitals.fromJS(resultData200) : new ProjectInformationInitals();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectInformationInitals>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInformation/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_ProjectInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInformation/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProjectInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProjectInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_ProjectInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProjectInfo.fromJS(resultData200) : new Dto_ProjectInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProjectInfo>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_ProjectInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectInformation/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_ProjectInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_ProjectInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_ProjectInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_ProjectInfo.fromJS(resultData200) : new PagedResultDtoOfDto_ProjectInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_ProjectInfo>(<any>null);
    }
}

@Injectable()
export class ProjectLocationInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllRiverBasin(): Observable<Dto_MajorRiverBasin[]> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/GetAllRiverBasin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRiverBasin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRiverBasin(<any>response_);
                } catch (e) {
                    return <Observable<Dto_MajorRiverBasin[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_MajorRiverBasin[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRiverBasin(response: HttpResponseBase): Observable<Dto_MajorRiverBasin[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_MajorRiverBasin.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_MajorRiverBasin[]>(<any>null);
    }

    /**
     * @param riverBasinName (optional) 
     * @return Success
     */
    createRiverBasin(riverBasinName: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/CreateRiverBasin?";
        if (riverBasinName !== undefined)
            url_ += "riverBasinName=" + encodeURIComponent("" + riverBasinName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRiverBasin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRiverBasin(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateRiverBasin(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getLocationInfoDetailByProjectId(projectId: string | null | undefined): Observable<Dto_LocationInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/GetLocationInfoDetailByProjectId?";
        if (projectId !== undefined)
            url_ += "ProjectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationInfoDetailByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationInfoDetailByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationInfoDetailByProjectId(response: HttpResponseBase): Observable<Dto_LocationInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationInfo.fromJS(resultData200) : new Dto_LocationInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_LocationInfo | null | undefined): Observable<Dto_LocationInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationInfo>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_LocationInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationInfo.fromJS(resultData200) : new Dto_LocationInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_LocationInfo | null | undefined): Observable<Dto_LocationInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_LocationInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationInfo.fromJS(resultData200) : new Dto_LocationInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_LocationInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_LocationInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_LocationInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_LocationInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_LocationInfo.fromJS(resultData200) : new Dto_LocationInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_LocationInfo>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_LocationInfo> {
        let url_ = this.baseUrl + "/api/services/app/ProjectLocationInfo/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_LocationInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_LocationInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_LocationInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_LocationInfo.fromJS(resultData200) : new PagedResultDtoOfDto_LocationInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_LocationInfo>(<any>null);
    }
}

@Injectable()
export class ProjectStatusServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_ProjectStatus> {
        let url_ = this.baseUrl + "/api/services/app/ProjectStatus/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_ProjectStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProjectStatus.fromJS(resultData200) : new Dto_ProjectStatus();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProjectStatus>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_ProjectStatus> {
        let url_ = this.baseUrl + "/api/services/app/ProjectStatus/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_ProjectStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_ProjectStatus.fromJS(resultData200) : new PagedResultDtoOfDto_ProjectStatus();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_ProjectStatus>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_ProjectStatus | null | undefined): Observable<Dto_ProjectStatus> {
        let url_ = this.baseUrl + "/api/services/app/ProjectStatus/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_ProjectStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProjectStatus.fromJS(resultData200) : new Dto_ProjectStatus();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProjectStatus>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_ProjectStatus | null | undefined): Observable<Dto_ProjectStatus> {
        let url_ = this.baseUrl + "/api/services/app/ProjectStatus/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_ProjectStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_ProjectStatus.fromJS(resultData200) : new Dto_ProjectStatus();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_ProjectStatus>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ProjectStatus/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ProvienceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfDto_Provience> {
        let url_ = this.baseUrl + "/api/services/app/Provience/GetAll?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_Provience>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_Provience>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_Provience> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_Provience.fromJS(resultData200) : new PagedResultDtoOfDto_Provience();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_Provience>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_Provience> {
        let url_ = this.baseUrl + "/api/services/app/Provience/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Provience>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Provience>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_Provience> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Provience.fromJS(resultData200) : new Dto_Provience();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Provience>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_Provience | null | undefined): Observable<Dto_Provience> {
        let url_ = this.baseUrl + "/api/services/app/Provience/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Provience>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Provience>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_Provience> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Provience.fromJS(resultData200) : new Dto_Provience();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Provience>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_Provience | null | undefined): Observable<Dto_Provience> {
        let url_ = this.baseUrl + "/api/services/app/Provience/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Provience>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Provience>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_Provience> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Provience.fromJS(resultData200) : new Dto_Provience();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Provience>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Provience/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RiverHydrologyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getRiverHydrologyInfoByProjectId(projectId: string | null | undefined): Observable<Dto_RiverHydrology> {
        let url_ = this.baseUrl + "/api/services/app/RiverHydrology/GetRiverHydrologyInfoByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRiverHydrologyInfoByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRiverHydrologyInfoByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_RiverHydrology>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_RiverHydrology>><any>_observableThrow(response_);
        }));
    }

    protected processGetRiverHydrologyInfoByProjectId(response: HttpResponseBase): Observable<Dto_RiverHydrology> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_RiverHydrology.fromJS(resultData200) : new Dto_RiverHydrology();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_RiverHydrology>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_RiverHydrology | null | undefined): Observable<Dto_RiverHydrology> {
        let url_ = this.baseUrl + "/api/services/app/RiverHydrology/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_RiverHydrology>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_RiverHydrology>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_RiverHydrology> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_RiverHydrology.fromJS(resultData200) : new Dto_RiverHydrology();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_RiverHydrology>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_RiverHydrology | null | undefined): Observable<Dto_RiverHydrology> {
        let url_ = this.baseUrl + "/api/services/app/RiverHydrology/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_RiverHydrology>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_RiverHydrology>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_RiverHydrology> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_RiverHydrology.fromJS(resultData200) : new Dto_RiverHydrology();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_RiverHydrology>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RiverHydrology/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_RiverHydrology> {
        let url_ = this.baseUrl + "/api/services/app/RiverHydrology/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_RiverHydrology>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_RiverHydrology>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_RiverHydrology> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_RiverHydrology.fromJS(resultData200) : new Dto_RiverHydrology();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_RiverHydrology>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_RiverHydrology> {
        let url_ = this.baseUrl + "/api/services/app/RiverHydrology/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_RiverHydrology>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_RiverHydrology>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_RiverHydrology> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_RiverHydrology.fromJS(resultData200) : new PagedResultDtoOfDto_RiverHydrology();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_RiverHydrology>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRolesAsync(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRolesAsync?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRolesAsync(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRolesAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRolesAsync(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: RoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class SecondaryCanalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param branchCanalId (optional) 
     * @return Success
     */
    getSecondaryCanalsByBranchCanalId(branchCanalId: number | null | undefined): Observable<Dto_SecondaryCanal[]> {
        let url_ = this.baseUrl + "/api/services/app/SecondaryCanal/GetSecondaryCanalsByBranchCanalId?";
        if (branchCanalId !== undefined)
            url_ += "BranchCanalId=" + encodeURIComponent("" + branchCanalId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSecondaryCanalsByBranchCanalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSecondaryCanalsByBranchCanalId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SecondaryCanal[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SecondaryCanal[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSecondaryCanalsByBranchCanalId(response: HttpResponseBase): Observable<Dto_SecondaryCanal[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_SecondaryCanal.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SecondaryCanal[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_SecondaryCanal | null | undefined): Observable<Dto_SecondaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/SecondaryCanal/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SecondaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SecondaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_SecondaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_SecondaryCanal.fromJS(resultData200) : new Dto_SecondaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SecondaryCanal>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_SecondaryCanal | null | undefined): Observable<Dto_SecondaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/SecondaryCanal/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SecondaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SecondaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_SecondaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_SecondaryCanal.fromJS(resultData200) : new Dto_SecondaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SecondaryCanal>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SecondaryCanal/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_SecondaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/SecondaryCanal/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SecondaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SecondaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_SecondaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_SecondaryCanal.fromJS(resultData200) : new Dto_SecondaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SecondaryCanal>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_SecondaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/SecondaryCanal/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_SecondaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_SecondaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_SecondaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_SecondaryCanal.fromJS(resultData200) : new PagedResultDtoOfDto_SecondaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_SecondaryCanal>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class SocialInformationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getSocialInfoByProjectId(projectId: string | null | undefined): Observable<Dto_SocialInfoDetailListModel[]> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/GetSocialInfoByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSocialInfoByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSocialInfoByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SocialInfoDetailListModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SocialInfoDetailListModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSocialInfoByProjectId(response: HttpResponseBase): Observable<Dto_SocialInfoDetailListModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_SocialInfoDetailListModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SocialInfoDetailListModel[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSocialInfoById(id: number | null | undefined): Observable<Dto_SocialInfoDetailListModel> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/GetSocialInfoById?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSocialInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSocialInfoById(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SocialInfoDetailListModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SocialInfoDetailListModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetSocialInfoById(response: HttpResponseBase): Observable<Dto_SocialInfoDetailListModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_SocialInfoDetailListModel.fromJS(resultData200) : new Dto_SocialInfoDetailListModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SocialInfoDetailListModel>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    saveSocialInfoData(input: Dto_SocialInfoDataModel | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/SaveSocialInfoData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveSocialInfoData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveSocialInfoData(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processSaveSocialInfoData(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_SocialInfo | null | undefined): Observable<Dto_SocialInfo> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SocialInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SocialInfo>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_SocialInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_SocialInfo.fromJS(resultData200) : new Dto_SocialInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SocialInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_SocialInfo | null | undefined): Observable<Dto_SocialInfo> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SocialInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SocialInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_SocialInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_SocialInfo.fromJS(resultData200) : new Dto_SocialInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SocialInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_SocialInfo> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_SocialInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_SocialInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_SocialInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_SocialInfo.fromJS(resultData200) : new Dto_SocialInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_SocialInfo>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_SocialInfo> {
        let url_ = this.baseUrl + "/api/services/app/SocialInformation/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_SocialInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_SocialInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_SocialInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_SocialInfo.fromJS(resultData200) : new PagedResultDtoOfDto_SocialInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_SocialInfo>(<any>null);
    }
}

@Injectable()
export class SpurServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getSpurListByProjectId(projectId: string | null | undefined): Observable<Dto_Spur[]> {
        let url_ = this.baseUrl + "/api/services/app/Spur/GetSpurListByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpurListByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpurListByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Spur[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Spur[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpurListByProjectId(response: HttpResponseBase): Observable<Dto_Spur[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_Spur.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Spur[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Spur/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_Spur | null | undefined): Observable<Dto_Spur> {
        let url_ = this.baseUrl + "/api/services/app/Spur/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Spur>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Spur>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_Spur> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Spur.fromJS(resultData200) : new Dto_Spur();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Spur>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_Spur | null | undefined): Observable<Dto_Spur> {
        let url_ = this.baseUrl + "/api/services/app/Spur/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Spur>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Spur>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_Spur> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Spur.fromJS(resultData200) : new Dto_Spur();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Spur>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_Spur> {
        let url_ = this.baseUrl + "/api/services/app/Spur/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_Spur>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_Spur>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_Spur> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_Spur.fromJS(resultData200) : new Dto_Spur();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_Spur>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_Spur> {
        let url_ = this.baseUrl + "/api/services/app/Spur/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_Spur>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_Spur>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_Spur> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_Spur.fromJS(resultData200) : new PagedResultDtoOfDto_Spur();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_Spur>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: TenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TertiaryCanalServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param secondaryCanalId (optional) 
     * @return Success
     */
    getTertiaryCanalBySecondaryCanalId(secondaryCanalId: number | null | undefined): Observable<Dto_TertiaryCanal[]> {
        let url_ = this.baseUrl + "/api/services/app/TertiaryCanal/GetTertiaryCanalBySecondaryCanalId?";
        if (secondaryCanalId !== undefined)
            url_ += "SecondaryCanalId=" + encodeURIComponent("" + secondaryCanalId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTertiaryCanalBySecondaryCanalId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTertiaryCanalBySecondaryCanalId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_TertiaryCanal[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_TertiaryCanal[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTertiaryCanalBySecondaryCanalId(response: HttpResponseBase): Observable<Dto_TertiaryCanal[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_TertiaryCanal.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_TertiaryCanal[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_TertiaryCanal | null | undefined): Observable<Dto_TertiaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/TertiaryCanal/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_TertiaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_TertiaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_TertiaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_TertiaryCanal.fromJS(resultData200) : new Dto_TertiaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_TertiaryCanal>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_TertiaryCanal | null | undefined): Observable<Dto_TertiaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/TertiaryCanal/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_TertiaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_TertiaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_TertiaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_TertiaryCanal.fromJS(resultData200) : new Dto_TertiaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_TertiaryCanal>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TertiaryCanal/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_TertiaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/TertiaryCanal/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_TertiaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_TertiaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_TertiaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_TertiaryCanal.fromJS(resultData200) : new Dto_TertiaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_TertiaryCanal>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_TertiaryCanal> {
        let url_ = this.baseUrl + "/api/services/app/TertiaryCanal/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_TertiaryCanal>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_TertiaryCanal>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_TertiaryCanal> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_TertiaryCanal.fromJS(resultData200) : new PagedResultDtoOfDto_TertiaryCanal();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_TertiaryCanal>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: UserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordDto | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
    }
}

@Injectable()
export class UserProjectServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUsersNotAssignedToProject(): Observable<ListResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProject/GetUsersNotAssignedToProject";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersNotAssignedToProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersNotAssignedToProject(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersNotAssignedToProject(response: HttpResponseBase): Observable<ListResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserDto.fromJS(resultData200) : new ListResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_UserProject | null | undefined): Observable<Dto_UserProject> {
        let url_ = this.baseUrl + "/api/services/app/UserProject/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_UserProject>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_UserProject>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_UserProject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_UserProject.fromJS(resultData200) : new Dto_UserProject();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_UserProject>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_UserProject | null | undefined): Observable<Dto_UserProject> {
        let url_ = this.baseUrl + "/api/services/app/UserProject/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_UserProject>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_UserProject>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_UserProject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_UserProject.fromJS(resultData200) : new Dto_UserProject();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_UserProject>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserProject/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | null | undefined): Observable<Dto_UserProject> {
        let url_ = this.baseUrl + "/api/services/app/UserProject/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_UserProject>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_UserProject>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_UserProject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_UserProject.fromJS(resultData200) : new Dto_UserProject();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_UserProject>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_UserProject> {
        let url_ = this.baseUrl + "/api/services/app/UserProject/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_UserProject>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_UserProject>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_UserProject> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_UserProject.fromJS(resultData200) : new PagedResultDtoOfDto_UserProject();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_UserProject>(<any>null);
    }
}

@Injectable()
export class WaterInducedDisasterModelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getWaterInducedDisasterDataByProjectId(projectId: string | null | undefined): Observable<Dto_WaterInducedDisasterModel> {
        let url_ = this.baseUrl + "/api/services/app/WaterInducedDisasterModel/GetWaterInducedDisasterDataByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWaterInducedDisasterDataByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWaterInducedDisasterDataByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetWaterInducedDisasterDataByProjectId(response: HttpResponseBase): Observable<Dto_WaterInducedDisasterModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WaterInducedDisasterModel.fromJS(resultData200) : new Dto_WaterInducedDisasterModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WaterInducedDisasterModel>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_WaterInducedDisasterModel | null | undefined): Observable<Dto_WaterInducedDisasterModel> {
        let url_ = this.baseUrl + "/api/services/app/WaterInducedDisasterModel/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_WaterInducedDisasterModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WaterInducedDisasterModel.fromJS(resultData200) : new Dto_WaterInducedDisasterModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WaterInducedDisasterModel>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_WaterInducedDisasterModel | null | undefined): Observable<Dto_WaterInducedDisasterModel> {
        let url_ = this.baseUrl + "/api/services/app/WaterInducedDisasterModel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_WaterInducedDisasterModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WaterInducedDisasterModel.fromJS(resultData200) : new Dto_WaterInducedDisasterModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WaterInducedDisasterModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WaterInducedDisasterModel/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_WaterInducedDisasterModel> {
        let url_ = this.baseUrl + "/api/services/app/WaterInducedDisasterModel/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WaterInducedDisasterModel>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_WaterInducedDisasterModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WaterInducedDisasterModel.fromJS(resultData200) : new Dto_WaterInducedDisasterModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WaterInducedDisasterModel>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_WaterInducedDisasterModel> {
        let url_ = this.baseUrl + "/api/services/app/WaterInducedDisasterModel/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_WaterInducedDisasterModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_WaterInducedDisasterModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_WaterInducedDisasterModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_WaterInducedDisasterModel.fromJS(resultData200) : new PagedResultDtoOfDto_WaterInducedDisasterModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_WaterInducedDisasterModel>(<any>null);
    }
}

@Injectable()
export class WUAInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getWUAInfoDetailByProjectId(projectId: string | null | undefined): Observable<Dto_WUAInfo> {
        let url_ = this.baseUrl + "/api/services/app/WUAInfo/GetWUAInfoDetailByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWUAInfoDetailByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWUAInfoDetailByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUAInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUAInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetWUAInfoDetailByProjectId(response: HttpResponseBase): Observable<Dto_WUAInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WUAInfo.fromJS(resultData200) : new Dto_WUAInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUAInfo>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_WUAInfo | null | undefined): Observable<Dto_WUAInfo> {
        let url_ = this.baseUrl + "/api/services/app/WUAInfo/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUAInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUAInfo>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_WUAInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WUAInfo.fromJS(resultData200) : new Dto_WUAInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUAInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WUAInfo/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_WUAInfo | null | undefined): Observable<Dto_WUAInfo> {
        let url_ = this.baseUrl + "/api/services/app/WUAInfo/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUAInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUAInfo>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_WUAInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WUAInfo.fromJS(resultData200) : new Dto_WUAInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUAInfo>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_WUAInfo> {
        let url_ = this.baseUrl + "/api/services/app/WUAInfo/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUAInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUAInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_WUAInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WUAInfo.fromJS(resultData200) : new Dto_WUAInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUAInfo>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_WUAInfo> {
        let url_ = this.baseUrl + "/api/services/app/WUAInfo/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_WUAInfo>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_WUAInfo>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_WUAInfo> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_WUAInfo.fromJS(resultData200) : new PagedResultDtoOfDto_WUAInfo();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_WUAInfo>(<any>null);
    }
}

@Injectable()
export class WUATrainingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param projectId (optional) 
     * @return Success
     */
    getWUATrainingsListByProjectId(projectId: string | null | undefined): Observable<Dto_WUATraining[]> {
        let url_ = this.baseUrl + "/api/services/app/WUATrainings/GetWUATrainingsListByProjectId?";
        if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWUATrainingsListByProjectId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWUATrainingsListByProjectId(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUATraining[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUATraining[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWUATrainingsListByProjectId(response: HttpResponseBase): Observable<Dto_WUATraining[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Dto_WUATraining.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUATraining[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    create(input: Dto_WUATraining | null | undefined): Observable<Dto_WUATraining> {
        let url_ = this.baseUrl + "/api/services/app/WUATrainings/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUATraining>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUATraining>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Dto_WUATraining> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WUATraining.fromJS(resultData200) : new Dto_WUATraining();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUATraining>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WUATrainings/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    update(input: Dto_WUATraining | null | undefined): Observable<Dto_WUATraining> {
        let url_ = this.baseUrl + "/api/services/app/WUATrainings/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUATraining>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUATraining>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<Dto_WUATraining> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WUATraining.fromJS(resultData200) : new Dto_WUATraining();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUATraining>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<Dto_WUATraining> {
        let url_ = this.baseUrl + "/api/services/app/WUATrainings/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Dto_WUATraining>><any>_observableThrow(e);
                }
            } else
                return <Observable<Dto_WUATraining>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Dto_WUATraining> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Dto_WUATraining.fromJS(resultData200) : new Dto_WUATraining();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Dto_WUATraining>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAll(maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfDto_WUATraining> {
        let url_ = this.baseUrl + "/api/services/app/WUATrainings/GetAll?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDto_WUATraining>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDto_WUATraining>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfDto_WUATraining> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDto_WUATraining.fromJS(resultData200) : new PagedResultDtoOfDto_WUATraining();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDto_WUATraining>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class Dto_AgricultreInfoDetailModel implements IDto_AgricultreInfoDetailModel {
    id: number | undefined;
    cropId: number | undefined;
    cropIdName: string | undefined;
    plantingMonth: string | undefined;
    plantingWeek: string | undefined;
    cropArea: number | undefined;
    harvestingMonth: string | undefined;
    harvestingWeek: string | undefined;
    averageCropYield: number | undefined;
    averageCropPrice: number | undefined;
    seedInput: number | undefined;
    organicManureInput: number | undefined;
    dapInput: number | undefined;
    potashInput: number | undefined;
    ureaInput: number | undefined;
    humanLaborInput: number | undefined;
    animalLaborInput: number | undefined;
    machineLaborInput: number | undefined;
    seedPrice: number | undefined;
    organicManurePrice: number | undefined;
    dapPrice: number | undefined;
    potashPrice: number | undefined;
    ureaPrice: number | undefined;
    humanLaborPrice: number | undefined;
    animalLaborPrice: number | undefined;
    machineLaborPrice: number | undefined;
    isCropPatternExisting: boolean | undefined;
    projectId: string | undefined;

    constructor(data?: IDto_AgricultreInfoDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.cropId = data["cropId"];
            this.cropIdName = data["cropIdName"];
            this.plantingMonth = data["plantingMonth"];
            this.plantingWeek = data["plantingWeek"];
            this.cropArea = data["cropArea"];
            this.harvestingMonth = data["harvestingMonth"];
            this.harvestingWeek = data["harvestingWeek"];
            this.averageCropYield = data["averageCropYield"];
            this.averageCropPrice = data["averageCropPrice"];
            this.seedInput = data["seedInput"];
            this.organicManureInput = data["organicManureInput"];
            this.dapInput = data["dapInput"];
            this.potashInput = data["potashInput"];
            this.ureaInput = data["ureaInput"];
            this.humanLaborInput = data["humanLaborInput"];
            this.animalLaborInput = data["animalLaborInput"];
            this.machineLaborInput = data["machineLaborInput"];
            this.seedPrice = data["seedPrice"];
            this.organicManurePrice = data["organicManurePrice"];
            this.dapPrice = data["dapPrice"];
            this.potashPrice = data["potashPrice"];
            this.ureaPrice = data["ureaPrice"];
            this.humanLaborPrice = data["humanLaborPrice"];
            this.animalLaborPrice = data["animalLaborPrice"];
            this.machineLaborPrice = data["machineLaborPrice"];
            this.isCropPatternExisting = data["isCropPatternExisting"];
            this.projectId = data["projectId"];
        }
    }

    static fromJS(data: any): Dto_AgricultreInfoDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_AgricultreInfoDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cropId"] = this.cropId;
        data["cropIdName"] = this.cropIdName;
        data["plantingMonth"] = this.plantingMonth;
        data["plantingWeek"] = this.plantingWeek;
        data["cropArea"] = this.cropArea;
        data["harvestingMonth"] = this.harvestingMonth;
        data["harvestingWeek"] = this.harvestingWeek;
        data["averageCropYield"] = this.averageCropYield;
        data["averageCropPrice"] = this.averageCropPrice;
        data["seedInput"] = this.seedInput;
        data["organicManureInput"] = this.organicManureInput;
        data["dapInput"] = this.dapInput;
        data["potashInput"] = this.potashInput;
        data["ureaInput"] = this.ureaInput;
        data["humanLaborInput"] = this.humanLaborInput;
        data["animalLaborInput"] = this.animalLaborInput;
        data["machineLaborInput"] = this.machineLaborInput;
        data["seedPrice"] = this.seedPrice;
        data["organicManurePrice"] = this.organicManurePrice;
        data["dapPrice"] = this.dapPrice;
        data["potashPrice"] = this.potashPrice;
        data["ureaPrice"] = this.ureaPrice;
        data["humanLaborPrice"] = this.humanLaborPrice;
        data["animalLaborPrice"] = this.animalLaborPrice;
        data["machineLaborPrice"] = this.machineLaborPrice;
        data["isCropPatternExisting"] = this.isCropPatternExisting;
        data["projectId"] = this.projectId;
        return data; 
    }

    clone(): Dto_AgricultreInfoDetailModel {
        const json = this.toJSON();
        let result = new Dto_AgricultreInfoDetailModel();
        result.init(json);
        return result;
    }
}

export interface IDto_AgricultreInfoDetailModel {
    id: number | undefined;
    cropId: number | undefined;
    cropIdName: string | undefined;
    plantingMonth: string | undefined;
    plantingWeek: string | undefined;
    cropArea: number | undefined;
    harvestingMonth: string | undefined;
    harvestingWeek: string | undefined;
    averageCropYield: number | undefined;
    averageCropPrice: number | undefined;
    seedInput: number | undefined;
    organicManureInput: number | undefined;
    dapInput: number | undefined;
    potashInput: number | undefined;
    ureaInput: number | undefined;
    humanLaborInput: number | undefined;
    animalLaborInput: number | undefined;
    machineLaborInput: number | undefined;
    seedPrice: number | undefined;
    organicManurePrice: number | undefined;
    dapPrice: number | undefined;
    potashPrice: number | undefined;
    ureaPrice: number | undefined;
    humanLaborPrice: number | undefined;
    animalLaborPrice: number | undefined;
    machineLaborPrice: number | undefined;
    isCropPatternExisting: boolean | undefined;
    projectId: string | undefined;
}

export class Dto_CropName implements IDto_CropName {
    name: string | undefined;
    order: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_CropName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_CropName {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_CropName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_CropName {
        const json = this.toJSON();
        let result = new Dto_CropName();
        result.init(json);
        return result;
    }
}

export interface IDto_CropName {
    name: string | undefined;
    order: number | undefined;
    id: number | undefined;
}

export class Dto_AgricultreInfo implements IDto_AgricultreInfo {
    cropId: number | undefined;
    plantingMonth: string;
    plantingWeek: string;
    cropArea: number | undefined;
    harvestingMonth: string;
    harvestingWeek: string;
    averageCropYield: number | undefined;
    averageCropPrice: number | undefined;
    seedInput: number | undefined;
    organicManureInput: number | undefined;
    dapInput: number | undefined;
    potashInput: number | undefined;
    ureaInput: number | undefined;
    humanLaborInput: number | undefined;
    animalLaborInput: number | undefined;
    machineLaborInput: number | undefined;
    seedPrice: number | undefined;
    organicManurePrice: number | undefined;
    dapPrice: number | undefined;
    potashPrice: number | undefined;
    ureaPrice: number | undefined;
    humanLaborPrice: number | undefined;
    animalLaborPrice: number | undefined;
    machineLaborPrice: number | undefined;
    isCropPatternExisting: boolean | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_AgricultreInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cropId = data["cropId"];
            this.plantingMonth = data["plantingMonth"];
            this.plantingWeek = data["plantingWeek"];
            this.cropArea = data["cropArea"];
            this.harvestingMonth = data["harvestingMonth"];
            this.harvestingWeek = data["harvestingWeek"];
            this.averageCropYield = data["averageCropYield"];
            this.averageCropPrice = data["averageCropPrice"];
            this.seedInput = data["seedInput"];
            this.organicManureInput = data["organicManureInput"];
            this.dapInput = data["dapInput"];
            this.potashInput = data["potashInput"];
            this.ureaInput = data["ureaInput"];
            this.humanLaborInput = data["humanLaborInput"];
            this.animalLaborInput = data["animalLaborInput"];
            this.machineLaborInput = data["machineLaborInput"];
            this.seedPrice = data["seedPrice"];
            this.organicManurePrice = data["organicManurePrice"];
            this.dapPrice = data["dapPrice"];
            this.potashPrice = data["potashPrice"];
            this.ureaPrice = data["ureaPrice"];
            this.humanLaborPrice = data["humanLaborPrice"];
            this.animalLaborPrice = data["animalLaborPrice"];
            this.machineLaborPrice = data["machineLaborPrice"];
            this.isCropPatternExisting = data["isCropPatternExisting"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_AgricultreInfo {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_AgricultreInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cropId"] = this.cropId;
        data["plantingMonth"] = this.plantingMonth;
        data["plantingWeek"] = this.plantingWeek;
        data["cropArea"] = this.cropArea;
        data["harvestingMonth"] = this.harvestingMonth;
        data["harvestingWeek"] = this.harvestingWeek;
        data["averageCropYield"] = this.averageCropYield;
        data["averageCropPrice"] = this.averageCropPrice;
        data["seedInput"] = this.seedInput;
        data["organicManureInput"] = this.organicManureInput;
        data["dapInput"] = this.dapInput;
        data["potashInput"] = this.potashInput;
        data["ureaInput"] = this.ureaInput;
        data["humanLaborInput"] = this.humanLaborInput;
        data["animalLaborInput"] = this.animalLaborInput;
        data["machineLaborInput"] = this.machineLaborInput;
        data["seedPrice"] = this.seedPrice;
        data["organicManurePrice"] = this.organicManurePrice;
        data["dapPrice"] = this.dapPrice;
        data["potashPrice"] = this.potashPrice;
        data["ureaPrice"] = this.ureaPrice;
        data["humanLaborPrice"] = this.humanLaborPrice;
        data["animalLaborPrice"] = this.animalLaborPrice;
        data["machineLaborPrice"] = this.machineLaborPrice;
        data["isCropPatternExisting"] = this.isCropPatternExisting;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_AgricultreInfo {
        const json = this.toJSON();
        let result = new Dto_AgricultreInfo();
        result.init(json);
        return result;
    }
}

export interface IDto_AgricultreInfo {
    cropId: number | undefined;
    plantingMonth: string;
    plantingWeek: string;
    cropArea: number | undefined;
    harvestingMonth: string;
    harvestingWeek: string;
    averageCropYield: number | undefined;
    averageCropPrice: number | undefined;
    seedInput: number | undefined;
    organicManureInput: number | undefined;
    dapInput: number | undefined;
    potashInput: number | undefined;
    ureaInput: number | undefined;
    humanLaborInput: number | undefined;
    animalLaborInput: number | undefined;
    machineLaborInput: number | undefined;
    seedPrice: number | undefined;
    organicManurePrice: number | undefined;
    dapPrice: number | undefined;
    potashPrice: number | undefined;
    ureaPrice: number | undefined;
    humanLaborPrice: number | undefined;
    animalLaborPrice: number | undefined;
    machineLaborPrice: number | undefined;
    isCropPatternExisting: boolean | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_AgricultreInfo implements IPagedResultDtoOfDto_AgricultreInfo {
    totalCount: number | undefined;
    items: Dto_AgricultreInfo[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_AgricultreInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_AgricultreInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_AgricultreInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_AgricultreInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_AgricultreInfo {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_AgricultreInfo();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_AgricultreInfo {
    totalCount: number | undefined;
    items: Dto_AgricultreInfo[] | undefined;
}

export class Dto_AgricultureDetail implements IDto_AgricultureDetail {
    projectId: string | undefined;
    existingTotalCultivatedArea: number | undefined;
    existingCropIntensity: number | undefined;
    proposedTotalCultivatedArea: number | undefined;
    proposedCropIntensity: number | undefined;
    nearestAgricultureOffice: string | undefined;
    agricultureOfficeDistance: number | undefined;
    nearestAgroVetOffice: string | undefined;
    agroVetOfficeDistance: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_AgricultureDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.existingTotalCultivatedArea = data["existingTotalCultivatedArea"];
            this.existingCropIntensity = data["existingCropIntensity"];
            this.proposedTotalCultivatedArea = data["proposedTotalCultivatedArea"];
            this.proposedCropIntensity = data["proposedCropIntensity"];
            this.nearestAgricultureOffice = data["nearestAgricultureOffice"];
            this.agricultureOfficeDistance = data["agricultureOfficeDistance"];
            this.nearestAgroVetOffice = data["nearestAgroVetOffice"];
            this.agroVetOfficeDistance = data["agroVetOfficeDistance"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_AgricultureDetail {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_AgricultureDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["existingTotalCultivatedArea"] = this.existingTotalCultivatedArea;
        data["existingCropIntensity"] = this.existingCropIntensity;
        data["proposedTotalCultivatedArea"] = this.proposedTotalCultivatedArea;
        data["proposedCropIntensity"] = this.proposedCropIntensity;
        data["nearestAgricultureOffice"] = this.nearestAgricultureOffice;
        data["agricultureOfficeDistance"] = this.agricultureOfficeDistance;
        data["nearestAgroVetOffice"] = this.nearestAgroVetOffice;
        data["agroVetOfficeDistance"] = this.agroVetOfficeDistance;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_AgricultureDetail {
        const json = this.toJSON();
        let result = new Dto_AgricultureDetail();
        result.init(json);
        return result;
    }
}

export interface IDto_AgricultureDetail {
    projectId: string | undefined;
    existingTotalCultivatedArea: number | undefined;
    existingCropIntensity: number | undefined;
    proposedTotalCultivatedArea: number | undefined;
    proposedCropIntensity: number | undefined;
    nearestAgricultureOffice: string | undefined;
    agricultureOfficeDistance: number | undefined;
    nearestAgroVetOffice: string | undefined;
    agroVetOfficeDistance: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_AgricultureDetail implements IPagedResultDtoOfDto_AgricultureDetail {
    totalCount: number | undefined;
    items: Dto_AgricultureDetail[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_AgricultureDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_AgricultureDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_AgricultureDetail {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_AgricultureDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_AgricultureDetail {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_AgricultureDetail();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_AgricultureDetail {
    totalCount: number | undefined;
    items: Dto_AgricultureDetail[] | undefined;
}

export class Dto_BranchCanal implements IDto_BranchCanal {
    name: string | undefined;
    gca: number | undefined;
    cca: number | undefined;
    unlinedTypeCanalLength: number | undefined;
    linedTypeCanalLength: number | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    canalStructure: string | undefined;
    noOfSecondaryCanal: number | undefined;
    mainCanalId: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_BranchCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.gca = data["gca"];
            this.cca = data["cca"];
            this.unlinedTypeCanalLength = data["unlinedTypeCanalLength"];
            this.linedTypeCanalLength = data["linedTypeCanalLength"];
            this.totalLength = data["totalLength"];
            this.designDischarge = data["designDischarge"];
            this.canalStructure = data["canalStructure"];
            this.noOfSecondaryCanal = data["noOfSecondaryCanal"];
            this.mainCanalId = data["mainCanalId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_BranchCanal {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_BranchCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["gca"] = this.gca;
        data["cca"] = this.cca;
        data["unlinedTypeCanalLength"] = this.unlinedTypeCanalLength;
        data["linedTypeCanalLength"] = this.linedTypeCanalLength;
        data["totalLength"] = this.totalLength;
        data["designDischarge"] = this.designDischarge;
        data["canalStructure"] = this.canalStructure;
        data["noOfSecondaryCanal"] = this.noOfSecondaryCanal;
        data["mainCanalId"] = this.mainCanalId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_BranchCanal {
        const json = this.toJSON();
        let result = new Dto_BranchCanal();
        result.init(json);
        return result;
    }
}

export interface IDto_BranchCanal {
    name: string | undefined;
    gca: number | undefined;
    cca: number | undefined;
    unlinedTypeCanalLength: number | undefined;
    linedTypeCanalLength: number | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    canalStructure: string | undefined;
    noOfSecondaryCanal: number | undefined;
    mainCanalId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_BranchCanal implements IPagedResultDtoOfDto_BranchCanal {
    totalCount: number | undefined;
    items: Dto_BranchCanal[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_BranchCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_BranchCanal.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_BranchCanal {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_BranchCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_BranchCanal {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_BranchCanal();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_BranchCanal {
    totalCount: number | undefined;
    items: Dto_BranchCanal[] | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class Dto_ContractManagement implements IDto_ContractManagement {
    projectCost: number | undefined;
    financialGON: number | undefined;
    financialWUA: number | undefined;
    financialDonar: number | undefined;
    financialOthers: number | undefined;
    icbNumber: number | undefined;
    icbEstimatedCost: number | undefined;
    ncbNumber: number | undefined;
    ncbEstimatedCost: number | undefined;
    wuaNumber: number | undefined;
    wuaEstimatedCost: number | undefined;
    contractId: string | undefined;
    contractorName: string | undefined;
    contractName: string | undefined;
    agreementDate: moment.Moment | undefined;
    contractType: string | undefined;
    contractMethod: string | undefined;
    isVariation: boolean | undefined;
    initialContractAmnt: number | undefined;
    variationAmnt: number | undefined;
    finalContractAmnt: number | undefined;
    contractVariationApprovedDate: moment.Moment | undefined;
    contractStatus: boolean | undefined;
    noOfTimesExtension: number | undefined;
    contractVariationApprovedBy: string | undefined;
    reasonsForContractVariation: string | undefined;
    physicalProgressNote: string | undefined;
    physicalProgressPercent: number | undefined;
    physicalProgressDate: moment.Moment | undefined;
    financialProgressNote: string | undefined;
    financialProgressPercent: number | undefined;
    financialProgressAmount: number | undefined;
    financialProgressDate: moment.Moment | undefined;
    isTimeVariation: boolean | undefined;
    timeVariationInitialDueDate: moment.Moment | undefined;
    timeVariationExtendedDueDate: moment.Moment | undefined;
    timeVariationApprovedDate: moment.Moment | undefined;
    noOfTimeExtension: number | undefined;
    timeVariationApprovedBy: string | undefined;
    reasonsForTimeExtension: string | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_ContractManagement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectCost = data["projectCost"];
            this.financialGON = data["financialGON"];
            this.financialWUA = data["financialWUA"];
            this.financialDonar = data["financialDonar"];
            this.financialOthers = data["financialOthers"];
            this.icbNumber = data["icbNumber"];
            this.icbEstimatedCost = data["icbEstimatedCost"];
            this.ncbNumber = data["ncbNumber"];
            this.ncbEstimatedCost = data["ncbEstimatedCost"];
            this.wuaNumber = data["wuaNumber"];
            this.wuaEstimatedCost = data["wuaEstimatedCost"];
            this.contractId = data["contractId"];
            this.contractorName = data["contractorName"];
            this.contractName = data["contractName"];
            this.agreementDate = data["agreementDate"] ? moment(data["agreementDate"].toString()) : <any>undefined;
            this.contractType = data["contractType"];
            this.contractMethod = data["contractMethod"];
            this.isVariation = data["isVariation"];
            this.initialContractAmnt = data["initialContractAmnt"];
            this.variationAmnt = data["variationAmnt"];
            this.finalContractAmnt = data["finalContractAmnt"];
            this.contractVariationApprovedDate = data["contractVariationApprovedDate"] ? moment(data["contractVariationApprovedDate"].toString()) : <any>undefined;
            this.contractStatus = data["contractStatus"];
            this.noOfTimesExtension = data["noOfTimesExtension"];
            this.contractVariationApprovedBy = data["contractVariationApprovedBy"];
            this.reasonsForContractVariation = data["reasonsForContractVariation"];
            this.physicalProgressNote = data["physicalProgressNote"];
            this.physicalProgressPercent = data["physicalProgressPercent"];
            this.physicalProgressDate = data["physicalProgressDate"] ? moment(data["physicalProgressDate"].toString()) : <any>undefined;
            this.financialProgressNote = data["financialProgressNote"];
            this.financialProgressPercent = data["financialProgressPercent"];
            this.financialProgressAmount = data["financialProgressAmount"];
            this.financialProgressDate = data["financialProgressDate"] ? moment(data["financialProgressDate"].toString()) : <any>undefined;
            this.isTimeVariation = data["isTimeVariation"];
            this.timeVariationInitialDueDate = data["timeVariationInitialDueDate"] ? moment(data["timeVariationInitialDueDate"].toString()) : <any>undefined;
            this.timeVariationExtendedDueDate = data["timeVariationExtendedDueDate"] ? moment(data["timeVariationExtendedDueDate"].toString()) : <any>undefined;
            this.timeVariationApprovedDate = data["timeVariationApprovedDate"] ? moment(data["timeVariationApprovedDate"].toString()) : <any>undefined;
            this.noOfTimeExtension = data["noOfTimeExtension"];
            this.timeVariationApprovedBy = data["timeVariationApprovedBy"];
            this.reasonsForTimeExtension = data["reasonsForTimeExtension"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_ContractManagement {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_ContractManagement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectCost"] = this.projectCost;
        data["financialGON"] = this.financialGON;
        data["financialWUA"] = this.financialWUA;
        data["financialDonar"] = this.financialDonar;
        data["financialOthers"] = this.financialOthers;
        data["icbNumber"] = this.icbNumber;
        data["icbEstimatedCost"] = this.icbEstimatedCost;
        data["ncbNumber"] = this.ncbNumber;
        data["ncbEstimatedCost"] = this.ncbEstimatedCost;
        data["wuaNumber"] = this.wuaNumber;
        data["wuaEstimatedCost"] = this.wuaEstimatedCost;
        data["contractId"] = this.contractId;
        data["contractorName"] = this.contractorName;
        data["contractName"] = this.contractName;
        data["agreementDate"] = this.agreementDate ? this.agreementDate.toISOString() : <any>undefined;
        data["contractType"] = this.contractType;
        data["contractMethod"] = this.contractMethod;
        data["isVariation"] = this.isVariation;
        data["initialContractAmnt"] = this.initialContractAmnt;
        data["variationAmnt"] = this.variationAmnt;
        data["finalContractAmnt"] = this.finalContractAmnt;
        data["contractVariationApprovedDate"] = this.contractVariationApprovedDate ? this.contractVariationApprovedDate.toISOString() : <any>undefined;
        data["contractStatus"] = this.contractStatus;
        data["noOfTimesExtension"] = this.noOfTimesExtension;
        data["contractVariationApprovedBy"] = this.contractVariationApprovedBy;
        data["reasonsForContractVariation"] = this.reasonsForContractVariation;
        data["physicalProgressNote"] = this.physicalProgressNote;
        data["physicalProgressPercent"] = this.physicalProgressPercent;
        data["physicalProgressDate"] = this.physicalProgressDate ? this.physicalProgressDate.toISOString() : <any>undefined;
        data["financialProgressNote"] = this.financialProgressNote;
        data["financialProgressPercent"] = this.financialProgressPercent;
        data["financialProgressAmount"] = this.financialProgressAmount;
        data["financialProgressDate"] = this.financialProgressDate ? this.financialProgressDate.toISOString() : <any>undefined;
        data["isTimeVariation"] = this.isTimeVariation;
        data["timeVariationInitialDueDate"] = this.timeVariationInitialDueDate ? this.timeVariationInitialDueDate.toISOString() : <any>undefined;
        data["timeVariationExtendedDueDate"] = this.timeVariationExtendedDueDate ? this.timeVariationExtendedDueDate.toISOString() : <any>undefined;
        data["timeVariationApprovedDate"] = this.timeVariationApprovedDate ? this.timeVariationApprovedDate.toISOString() : <any>undefined;
        data["noOfTimeExtension"] = this.noOfTimeExtension;
        data["timeVariationApprovedBy"] = this.timeVariationApprovedBy;
        data["reasonsForTimeExtension"] = this.reasonsForTimeExtension;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_ContractManagement {
        const json = this.toJSON();
        let result = new Dto_ContractManagement();
        result.init(json);
        return result;
    }
}

export interface IDto_ContractManagement {
    projectCost: number | undefined;
    financialGON: number | undefined;
    financialWUA: number | undefined;
    financialDonar: number | undefined;
    financialOthers: number | undefined;
    icbNumber: number | undefined;
    icbEstimatedCost: number | undefined;
    ncbNumber: number | undefined;
    ncbEstimatedCost: number | undefined;
    wuaNumber: number | undefined;
    wuaEstimatedCost: number | undefined;
    contractId: string | undefined;
    contractorName: string | undefined;
    contractName: string | undefined;
    agreementDate: moment.Moment | undefined;
    contractType: string | undefined;
    contractMethod: string | undefined;
    isVariation: boolean | undefined;
    initialContractAmnt: number | undefined;
    variationAmnt: number | undefined;
    finalContractAmnt: number | undefined;
    contractVariationApprovedDate: moment.Moment | undefined;
    contractStatus: boolean | undefined;
    noOfTimesExtension: number | undefined;
    contractVariationApprovedBy: string | undefined;
    reasonsForContractVariation: string | undefined;
    physicalProgressNote: string | undefined;
    physicalProgressPercent: number | undefined;
    physicalProgressDate: moment.Moment | undefined;
    financialProgressNote: string | undefined;
    financialProgressPercent: number | undefined;
    financialProgressAmount: number | undefined;
    financialProgressDate: moment.Moment | undefined;
    isTimeVariation: boolean | undefined;
    timeVariationInitialDueDate: moment.Moment | undefined;
    timeVariationExtendedDueDate: moment.Moment | undefined;
    timeVariationApprovedDate: moment.Moment | undefined;
    noOfTimeExtension: number | undefined;
    timeVariationApprovedBy: string | undefined;
    reasonsForTimeExtension: string | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_ContractManagement implements IPagedResultDtoOfDto_ContractManagement {
    totalCount: number | undefined;
    items: Dto_ContractManagement[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_ContractManagement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_ContractManagement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_ContractManagement {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_ContractManagement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_ContractManagement {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_ContractManagement();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_ContractManagement {
    totalCount: number | undefined;
    items: Dto_ContractManagement[] | undefined;
}

export class PagedResultDtoOfDto_CropName implements IPagedResultDtoOfDto_CropName {
    totalCount: number | undefined;
    items: Dto_CropName[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_CropName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_CropName.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_CropName {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_CropName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_CropName {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_CropName();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_CropName {
    totalCount: number | undefined;
    items: Dto_CropName[] | undefined;
}

export class Dto_LocationDistrict implements IDto_LocationDistrict {
    districtName: string | undefined;
    status: boolean | undefined;
    provienceId: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_LocationDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.districtName = data["districtName"];
            this.status = data["status"];
            this.provienceId = data["provienceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_LocationDistrict {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_LocationDistrict();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["districtName"] = this.districtName;
        data["status"] = this.status;
        data["provienceId"] = this.provienceId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_LocationDistrict {
        const json = this.toJSON();
        let result = new Dto_LocationDistrict();
        result.init(json);
        return result;
    }
}

export interface IDto_LocationDistrict {
    districtName: string | undefined;
    status: boolean | undefined;
    provienceId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_LocationDistrict implements IPagedResultDtoOfDto_LocationDistrict {
    totalCount: number | undefined;
    items: Dto_LocationDistrict[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_LocationDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_LocationDistrict.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_LocationDistrict {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_LocationDistrict();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_LocationDistrict {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_LocationDistrict();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_LocationDistrict {
    totalCount: number | undefined;
    items: Dto_LocationDistrict[] | undefined;
}

export class ListResultDtoOfDocumentDto implements IListResultDtoOfDocumentDto {
    items: DocumentDto[] | undefined;

    constructor(data?: IListResultDtoOfDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfDocumentDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfDocumentDto {
    items: DocumentDto[] | undefined;
}

export class DocumentDto implements IDocumentDto {
    document: string | undefined;
    displayName: string | undefined;
    docType: number | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.document = data["document"];
            this.displayName = data["displayName"];
            this.docType = data["docType"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document;
        data["displayName"] = this.displayName;
        data["docType"] = this.docType;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): DocumentDto {
        const json = this.toJSON();
        let result = new DocumentDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentDto {
    document: string | undefined;
    displayName: string | undefined;
    docType: number | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class CreateDocumentDto implements ICreateDocumentDto {
    document: string;
    displayName: string;
    docType: number;

    constructor(data?: ICreateDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.document = data["document"];
            this.displayName = data["displayName"];
            this.docType = data["docType"];
        }
    }

    static fromJS(data: any): CreateDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document;
        data["displayName"] = this.displayName;
        data["docType"] = this.docType;
        return data; 
    }

    clone(): CreateDocumentDto {
        const json = this.toJSON();
        let result = new CreateDocumentDto();
        result.init(json);
        return result;
    }
}

export interface ICreateDocumentDto {
    document: string;
    displayName: string;
    docType: number;
}

export class PagedResultDtoOfDocumentDto implements IPagedResultDtoOfDocumentDto {
    totalCount: number | undefined;
    items: DocumentDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(DocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDocumentDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDocumentDto {
    totalCount: number | undefined;
    items: DocumentDto[] | undefined;
}

export class Dto_EconomicInfo implements IDto_EconomicInfo {
    costingYear: number | undefined;
    totalProjectCost: number | undefined;
    eirr: number | undefined;
    bC1: number | undefined;
    discountRate1: number | undefined;
    bC2: number | undefined;
    discountRate2: number | undefined;
    benefitWithoutProject: number | undefined;
    benefitWithProject: number | undefined;
    projectLife: number | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_EconomicInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.costingYear = data["costingYear"];
            this.totalProjectCost = data["totalProjectCost"];
            this.eirr = data["eirr"];
            this.bC1 = data["bC1"];
            this.discountRate1 = data["discountRate1"];
            this.bC2 = data["bC2"];
            this.discountRate2 = data["discountRate2"];
            this.benefitWithoutProject = data["benefitWithoutProject"];
            this.benefitWithProject = data["benefitWithProject"];
            this.projectLife = data["projectLife"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_EconomicInfo {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_EconomicInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["costingYear"] = this.costingYear;
        data["totalProjectCost"] = this.totalProjectCost;
        data["eirr"] = this.eirr;
        data["bC1"] = this.bC1;
        data["discountRate1"] = this.discountRate1;
        data["bC2"] = this.bC2;
        data["discountRate2"] = this.discountRate2;
        data["benefitWithoutProject"] = this.benefitWithoutProject;
        data["benefitWithProject"] = this.benefitWithProject;
        data["projectLife"] = this.projectLife;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_EconomicInfo {
        const json = this.toJSON();
        let result = new Dto_EconomicInfo();
        result.init(json);
        return result;
    }
}

export interface IDto_EconomicInfo {
    costingYear: number | undefined;
    totalProjectCost: number | undefined;
    eirr: number | undefined;
    bC1: number | undefined;
    discountRate1: number | undefined;
    bC2: number | undefined;
    discountRate2: number | undefined;
    benefitWithoutProject: number | undefined;
    benefitWithProject: number | undefined;
    projectLife: number | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_EconomicInfo implements IPagedResultDtoOfDto_EconomicInfo {
    totalCount: number | undefined;
    items: Dto_EconomicInfo[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_EconomicInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_EconomicInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_EconomicInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_EconomicInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_EconomicInfo {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_EconomicInfo();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_EconomicInfo {
    totalCount: number | undefined;
    items: Dto_EconomicInfo[] | undefined;
}

export class Dto_Embankment implements IDto_Embankment {
    no: number | undefined;
    locationChainage: number | undefined;
    length: number | undefined;
    hfl: number | undefined;
    lwl: number | undefined;
    materails: string | undefined;
    designHeight: number | undefined;
    designTopWidth: number | undefined;
    designFreeBoard: number | undefined;
    designSlideSlope: number | undefined;
    designLengthOfLaunchingApron: number | undefined;
    designThicknessOfPitching: number | undefined;
    designThicknessOfFilter: number | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_Embankment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.no = data["no"];
            this.locationChainage = data["locationChainage"];
            this.length = data["length"];
            this.hfl = data["hfl"];
            this.lwl = data["lwl"];
            this.materails = data["materails"];
            this.designHeight = data["designHeight"];
            this.designTopWidth = data["designTopWidth"];
            this.designFreeBoard = data["designFreeBoard"];
            this.designSlideSlope = data["designSlideSlope"];
            this.designLengthOfLaunchingApron = data["designLengthOfLaunchingApron"];
            this.designThicknessOfPitching = data["designThicknessOfPitching"];
            this.designThicknessOfFilter = data["designThicknessOfFilter"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_Embankment {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_Embankment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["no"] = this.no;
        data["locationChainage"] = this.locationChainage;
        data["length"] = this.length;
        data["hfl"] = this.hfl;
        data["lwl"] = this.lwl;
        data["materails"] = this.materails;
        data["designHeight"] = this.designHeight;
        data["designTopWidth"] = this.designTopWidth;
        data["designFreeBoard"] = this.designFreeBoard;
        data["designSlideSlope"] = this.designSlideSlope;
        data["designLengthOfLaunchingApron"] = this.designLengthOfLaunchingApron;
        data["designThicknessOfPitching"] = this.designThicknessOfPitching;
        data["designThicknessOfFilter"] = this.designThicknessOfFilter;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_Embankment {
        const json = this.toJSON();
        let result = new Dto_Embankment();
        result.init(json);
        return result;
    }
}

export interface IDto_Embankment {
    no: number | undefined;
    locationChainage: number | undefined;
    length: number | undefined;
    hfl: number | undefined;
    lwl: number | undefined;
    materails: string | undefined;
    designHeight: number | undefined;
    designTopWidth: number | undefined;
    designFreeBoard: number | undefined;
    designSlideSlope: number | undefined;
    designLengthOfLaunchingApron: number | undefined;
    designThicknessOfPitching: number | undefined;
    designThicknessOfFilter: number | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_Embankment implements IPagedResultDtoOfDto_Embankment {
    totalCount: number | undefined;
    items: Dto_Embankment[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_Embankment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_Embankment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_Embankment {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_Embankment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_Embankment {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_Embankment();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_Embankment {
    totalCount: number | undefined;
    items: Dto_Embankment[] | undefined;
}

export class PagedResultDtoOfDto_EthicsInformation implements IPagedResultDtoOfDto_EthicsInformation {
    totalCount: number | undefined;
    items: Dto_EthicsInformation[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_EthicsInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_EthicsInformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_EthicsInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_EthicsInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_EthicsInformation {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_EthicsInformation();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_EthicsInformation {
    totalCount: number | undefined;
    items: Dto_EthicsInformation[] | undefined;
}

export class Dto_EthicsInformation implements IDto_EthicsInformation {
    name: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_EthicsInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_EthicsInformation {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_EthicsInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_EthicsInformation {
        const json = this.toJSON();
        let result = new Dto_EthicsInformation();
        result.init(json);
        return result;
    }
}

export interface IDto_EthicsInformation {
    name: string | undefined;
    id: number | undefined;
}

export class Dto_GraphData implements IDto_GraphData {
    displayName: string | undefined;
    dataValues: number | undefined;
    iType: number | undefined;
    displayOrder: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_GraphData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.dataValues = data["dataValues"];
            this.iType = data["iType"];
            this.displayOrder = data["displayOrder"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_GraphData {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_GraphData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["dataValues"] = this.dataValues;
        data["iType"] = this.iType;
        data["displayOrder"] = this.displayOrder;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_GraphData {
        const json = this.toJSON();
        let result = new Dto_GraphData();
        result.init(json);
        return result;
    }
}

export interface IDto_GraphData {
    displayName: string | undefined;
    dataValues: number | undefined;
    iType: number | undefined;
    displayOrder: number | undefined;
    id: number | undefined;
}

export class GraphData_Dto_ProcedureCall implements IGraphData_Dto_ProcedureCall {
    displayName: string | undefined;
    values: number | undefined;

    constructor(data?: IGraphData_Dto_ProcedureCall) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.values = data["values"];
        }
    }

    static fromJS(data: any): GraphData_Dto_ProcedureCall {
        data = typeof data === 'object' ? data : {};
        let result = new GraphData_Dto_ProcedureCall();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["values"] = this.values;
        return data; 
    }

    clone(): GraphData_Dto_ProcedureCall {
        const json = this.toJSON();
        let result = new GraphData_Dto_ProcedureCall();
        result.init(json);
        return result;
    }
}

export interface IGraphData_Dto_ProcedureCall {
    displayName: string | undefined;
    values: number | undefined;
}

export class PagedResultDtoOfDto_GraphData implements IPagedResultDtoOfDto_GraphData {
    totalCount: number | undefined;
    items: Dto_GraphData[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_GraphData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_GraphData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_GraphData {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_GraphData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_GraphData {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_GraphData();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_GraphData {
    totalCount: number | undefined;
    items: Dto_GraphData[] | undefined;
}

export class Dto_GroundWaterInformation implements IDto_GroundWaterInformation {
    tubewellNo: string | undefined;
    location: string | undefined;
    latitudeDegree: string | undefined;
    latitudeMin: string | undefined;
    latitudeSecond: string | undefined;
    longitudeDegree: string | undefined;
    longitudeMin: string | undefined;
    longitudeSecond: string | undefined;
    elevation: string | undefined;
    tubewellType: string | undefined;
    tubewellHousingPipeSize: number | undefined;
    tubewellScreenAndCastingPipeSize: number | undefined;
    staticWaterLevel: number | undefined;
    aquiferMaterail: string | undefined;
    totalDrillDepth: number | undefined;
    housingLength: number | undefined;
    screenLength: number | undefined;
    typeOfScreen: string | undefined;
    pumpingDischarge: number | undefined;
    drawdown: number | undefined;
    aquiferStorageCoefficient: number | undefined;
    aquifertransmissivity: number | undefined;
    brandOfPump: string | undefined;
    power: number | undefined;
    head: number | undefined;
    pumpDischarge: number | undefined;
    efficienyOfMoter: number | undefined;
    efficienyOfPump: number | undefined;
    pumpLoweringDepth: number | undefined;
    columnPipeSize: number | undefined;
    columnType: string | undefined;
    sizeOfPumpHouse: string | undefined;
    heightOfOverheadTank: number | undefined;
    volumeOverheadTank: number | undefined;
    typeOfDistributionSystem: string | undefined;
    noOfOutlets: number | undefined;
    lengthOfOpenChannel: number | undefined;
    sizeOfAlphaValve: number | undefined;
    pipeMaterial: string | undefined;
    lengthOfPipe: number | undefined;
    noOfSurgeRaiser: number | undefined;
    lengthOf11KvHtTransLine: number | undefined;
    lengthof440VLtTransLine: number | undefined;
    numberOfPoles: number | undefined;
    transformerCapacity: number | undefined;
    controlPanel: number | undefined;
    voltageStabilizer: number | undefined;
    projectId: string | undefined;
    tubeWellName: string | undefined;
    commandArea: number | undefined;
    pumpInfoColumnTypeOther: string | undefined;
    numberofpolesheading_HT_LT: number | undefined;
    transformerBrand: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_GroundWaterInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tubewellNo = data["tubewellNo"];
            this.location = data["location"];
            this.latitudeDegree = data["latitudeDegree"];
            this.latitudeMin = data["latitudeMin"];
            this.latitudeSecond = data["latitudeSecond"];
            this.longitudeDegree = data["longitudeDegree"];
            this.longitudeMin = data["longitudeMin"];
            this.longitudeSecond = data["longitudeSecond"];
            this.elevation = data["elevation"];
            this.tubewellType = data["tubewellType"];
            this.tubewellHousingPipeSize = data["tubewellHousingPipeSize"];
            this.tubewellScreenAndCastingPipeSize = data["tubewellScreenAndCastingPipeSize"];
            this.staticWaterLevel = data["staticWaterLevel"];
            this.aquiferMaterail = data["aquiferMaterail"];
            this.totalDrillDepth = data["totalDrillDepth"];
            this.housingLength = data["housingLength"];
            this.screenLength = data["screenLength"];
            this.typeOfScreen = data["typeOfScreen"];
            this.pumpingDischarge = data["pumpingDischarge"];
            this.drawdown = data["drawdown"];
            this.aquiferStorageCoefficient = data["aquiferStorageCoefficient"];
            this.aquifertransmissivity = data["aquifertransmissivity"];
            this.brandOfPump = data["brandOfPump"];
            this.power = data["power"];
            this.head = data["head"];
            this.pumpDischarge = data["pumpDischarge"];
            this.efficienyOfMoter = data["efficienyOfMoter"];
            this.efficienyOfPump = data["efficienyOfPump"];
            this.pumpLoweringDepth = data["pumpLoweringDepth"];
            this.columnPipeSize = data["columnPipeSize"];
            this.columnType = data["columnType"];
            this.sizeOfPumpHouse = data["sizeOfPumpHouse"];
            this.heightOfOverheadTank = data["heightOfOverheadTank"];
            this.volumeOverheadTank = data["volumeOverheadTank"];
            this.typeOfDistributionSystem = data["typeOfDistributionSystem"];
            this.noOfOutlets = data["noOfOutlets"];
            this.lengthOfOpenChannel = data["lengthOfOpenChannel"];
            this.sizeOfAlphaValve = data["sizeOfAlphaValve"];
            this.pipeMaterial = data["pipeMaterial"];
            this.lengthOfPipe = data["lengthOfPipe"];
            this.noOfSurgeRaiser = data["noOfSurgeRaiser"];
            this.lengthOf11KvHtTransLine = data["lengthOf11KvHtTransLine"];
            this.lengthof440VLtTransLine = data["lengthof440VLtTransLine"];
            this.numberOfPoles = data["numberOfPoles"];
            this.transformerCapacity = data["transformerCapacity"];
            this.controlPanel = data["controlPanel"];
            this.voltageStabilizer = data["voltageStabilizer"];
            this.projectId = data["projectId"];
            this.tubeWellName = data["tubeWellName"];
            this.commandArea = data["commandArea"];
            this.pumpInfoColumnTypeOther = data["pumpInfoColumnTypeOther"];
            this.numberofpolesheading_HT_LT = data["numberofpolesheading_HT_LT"];
            this.transformerBrand = data["transformerBrand"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_GroundWaterInformation {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_GroundWaterInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tubewellNo"] = this.tubewellNo;
        data["location"] = this.location;
        data["latitudeDegree"] = this.latitudeDegree;
        data["latitudeMin"] = this.latitudeMin;
        data["latitudeSecond"] = this.latitudeSecond;
        data["longitudeDegree"] = this.longitudeDegree;
        data["longitudeMin"] = this.longitudeMin;
        data["longitudeSecond"] = this.longitudeSecond;
        data["elevation"] = this.elevation;
        data["tubewellType"] = this.tubewellType;
        data["tubewellHousingPipeSize"] = this.tubewellHousingPipeSize;
        data["tubewellScreenAndCastingPipeSize"] = this.tubewellScreenAndCastingPipeSize;
        data["staticWaterLevel"] = this.staticWaterLevel;
        data["aquiferMaterail"] = this.aquiferMaterail;
        data["totalDrillDepth"] = this.totalDrillDepth;
        data["housingLength"] = this.housingLength;
        data["screenLength"] = this.screenLength;
        data["typeOfScreen"] = this.typeOfScreen;
        data["pumpingDischarge"] = this.pumpingDischarge;
        data["drawdown"] = this.drawdown;
        data["aquiferStorageCoefficient"] = this.aquiferStorageCoefficient;
        data["aquifertransmissivity"] = this.aquifertransmissivity;
        data["brandOfPump"] = this.brandOfPump;
        data["power"] = this.power;
        data["head"] = this.head;
        data["pumpDischarge"] = this.pumpDischarge;
        data["efficienyOfMoter"] = this.efficienyOfMoter;
        data["efficienyOfPump"] = this.efficienyOfPump;
        data["pumpLoweringDepth"] = this.pumpLoweringDepth;
        data["columnPipeSize"] = this.columnPipeSize;
        data["columnType"] = this.columnType;
        data["sizeOfPumpHouse"] = this.sizeOfPumpHouse;
        data["heightOfOverheadTank"] = this.heightOfOverheadTank;
        data["volumeOverheadTank"] = this.volumeOverheadTank;
        data["typeOfDistributionSystem"] = this.typeOfDistributionSystem;
        data["noOfOutlets"] = this.noOfOutlets;
        data["lengthOfOpenChannel"] = this.lengthOfOpenChannel;
        data["sizeOfAlphaValve"] = this.sizeOfAlphaValve;
        data["pipeMaterial"] = this.pipeMaterial;
        data["lengthOfPipe"] = this.lengthOfPipe;
        data["noOfSurgeRaiser"] = this.noOfSurgeRaiser;
        data["lengthOf11KvHtTransLine"] = this.lengthOf11KvHtTransLine;
        data["lengthof440VLtTransLine"] = this.lengthof440VLtTransLine;
        data["numberOfPoles"] = this.numberOfPoles;
        data["transformerCapacity"] = this.transformerCapacity;
        data["controlPanel"] = this.controlPanel;
        data["voltageStabilizer"] = this.voltageStabilizer;
        data["projectId"] = this.projectId;
        data["tubeWellName"] = this.tubeWellName;
        data["commandArea"] = this.commandArea;
        data["pumpInfoColumnTypeOther"] = this.pumpInfoColumnTypeOther;
        data["numberofpolesheading_HT_LT"] = this.numberofpolesheading_HT_LT;
        data["transformerBrand"] = this.transformerBrand;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_GroundWaterInformation {
        const json = this.toJSON();
        let result = new Dto_GroundWaterInformation();
        result.init(json);
        return result;
    }
}

export interface IDto_GroundWaterInformation {
    tubewellNo: string | undefined;
    location: string | undefined;
    latitudeDegree: string | undefined;
    latitudeMin: string | undefined;
    latitudeSecond: string | undefined;
    longitudeDegree: string | undefined;
    longitudeMin: string | undefined;
    longitudeSecond: string | undefined;
    elevation: string | undefined;
    tubewellType: string | undefined;
    tubewellHousingPipeSize: number | undefined;
    tubewellScreenAndCastingPipeSize: number | undefined;
    staticWaterLevel: number | undefined;
    aquiferMaterail: string | undefined;
    totalDrillDepth: number | undefined;
    housingLength: number | undefined;
    screenLength: number | undefined;
    typeOfScreen: string | undefined;
    pumpingDischarge: number | undefined;
    drawdown: number | undefined;
    aquiferStorageCoefficient: number | undefined;
    aquifertransmissivity: number | undefined;
    brandOfPump: string | undefined;
    power: number | undefined;
    head: number | undefined;
    pumpDischarge: number | undefined;
    efficienyOfMoter: number | undefined;
    efficienyOfPump: number | undefined;
    pumpLoweringDepth: number | undefined;
    columnPipeSize: number | undefined;
    columnType: string | undefined;
    sizeOfPumpHouse: string | undefined;
    heightOfOverheadTank: number | undefined;
    volumeOverheadTank: number | undefined;
    typeOfDistributionSystem: string | undefined;
    noOfOutlets: number | undefined;
    lengthOfOpenChannel: number | undefined;
    sizeOfAlphaValve: number | undefined;
    pipeMaterial: string | undefined;
    lengthOfPipe: number | undefined;
    noOfSurgeRaiser: number | undefined;
    lengthOf11KvHtTransLine: number | undefined;
    lengthof440VLtTransLine: number | undefined;
    numberOfPoles: number | undefined;
    transformerCapacity: number | undefined;
    controlPanel: number | undefined;
    voltageStabilizer: number | undefined;
    projectId: string | undefined;
    tubeWellName: string | undefined;
    commandArea: number | undefined;
    pumpInfoColumnTypeOther: string | undefined;
    numberofpolesheading_HT_LT: number | undefined;
    transformerBrand: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_GroundWaterInformation implements IPagedResultDtoOfDto_GroundWaterInformation {
    totalCount: number | undefined;
    items: Dto_GroundWaterInformation[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_GroundWaterInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_GroundWaterInformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_GroundWaterInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_GroundWaterInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_GroundWaterInformation {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_GroundWaterInformation();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_GroundWaterInformation {
    totalCount: number | undefined;
    items: Dto_GroundWaterInformation[] | undefined;
}

export class Dto_HeadWork implements IDto_HeadWork {
    headWorksType: string | undefined;
    headWorksTypeOther: string | undefined;
    barrageTotalLength: number | undefined;
    noOfBaysOrGates: number | undefined;
    lengthOfEachBayOpening: number | undefined;
    crestElevation: number | undefined;
    noOfUndersluice: number | undefined;
    noOfUndersluiceBaysOrGates: number | undefined;
    undersluiceLengthOfEachBayOpening: number | undefined;
    undersluiceCrestElevation: number | undefined;
    barrageNoOfHeadRegulators: number | undefined;
    barrageWidthHeadRegulators: number | undefined;
    barrageNoOfHeadRegulatorsBays: number | undefined;
    barrageWidthOfEachBayOpening: number | undefined;
    barrageCrestElevation: number | undefined;
    weirTotalLength: number | undefined;
    weirCrestElevation: number | undefined;
    weirNoOfUndersluice: number | undefined;
    weirNoOfUndersluiceBaysOrGates: number | undefined;
    weirUndersluiceLengthOfEachBayOpening: number | undefined;
    weirUndersluiceCrestElevation: number | undefined;
    weirNoOfHeadRegulators: number | undefined;
    weirWidthHeadRegulators: number | undefined;
    weirNoOfHeadRegulatorsBays: number | undefined;
    weirWidthOfEachBayOpening: number | undefined;
    weirHeadRegulatorsCrestElevation: number | undefined;
    bankIntakeIsGated: boolean | undefined;
    stillLevelLength: number | undefined;
    sizeOfOrificeWidth: number | undefined;
    sizeOfOrificeHeight: number | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_HeadWork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headWorksType = data["headWorksType"];
            this.headWorksTypeOther = data["headWorksTypeOther"];
            this.barrageTotalLength = data["barrageTotalLength"];
            this.noOfBaysOrGates = data["noOfBaysOrGates"];
            this.lengthOfEachBayOpening = data["lengthOfEachBayOpening"];
            this.crestElevation = data["crestElevation"];
            this.noOfUndersluice = data["noOfUndersluice"];
            this.noOfUndersluiceBaysOrGates = data["noOfUndersluiceBaysOrGates"];
            this.undersluiceLengthOfEachBayOpening = data["undersluiceLengthOfEachBayOpening"];
            this.undersluiceCrestElevation = data["undersluiceCrestElevation"];
            this.barrageNoOfHeadRegulators = data["barrageNoOfHeadRegulators"];
            this.barrageWidthHeadRegulators = data["barrageWidthHeadRegulators"];
            this.barrageNoOfHeadRegulatorsBays = data["barrageNoOfHeadRegulatorsBays"];
            this.barrageWidthOfEachBayOpening = data["barrageWidthOfEachBayOpening"];
            this.barrageCrestElevation = data["barrageCrestElevation"];
            this.weirTotalLength = data["weirTotalLength"];
            this.weirCrestElevation = data["weirCrestElevation"];
            this.weirNoOfUndersluice = data["weirNoOfUndersluice"];
            this.weirNoOfUndersluiceBaysOrGates = data["weirNoOfUndersluiceBaysOrGates"];
            this.weirUndersluiceLengthOfEachBayOpening = data["weirUndersluiceLengthOfEachBayOpening"];
            this.weirUndersluiceCrestElevation = data["weirUndersluiceCrestElevation"];
            this.weirNoOfHeadRegulators = data["weirNoOfHeadRegulators"];
            this.weirWidthHeadRegulators = data["weirWidthHeadRegulators"];
            this.weirNoOfHeadRegulatorsBays = data["weirNoOfHeadRegulatorsBays"];
            this.weirWidthOfEachBayOpening = data["weirWidthOfEachBayOpening"];
            this.weirHeadRegulatorsCrestElevation = data["weirHeadRegulatorsCrestElevation"];
            this.bankIntakeIsGated = data["bankIntakeIsGated"];
            this.stillLevelLength = data["stillLevelLength"];
            this.sizeOfOrificeWidth = data["sizeOfOrificeWidth"];
            this.sizeOfOrificeHeight = data["sizeOfOrificeHeight"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_HeadWork {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_HeadWork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headWorksType"] = this.headWorksType;
        data["headWorksTypeOther"] = this.headWorksTypeOther;
        data["barrageTotalLength"] = this.barrageTotalLength;
        data["noOfBaysOrGates"] = this.noOfBaysOrGates;
        data["lengthOfEachBayOpening"] = this.lengthOfEachBayOpening;
        data["crestElevation"] = this.crestElevation;
        data["noOfUndersluice"] = this.noOfUndersluice;
        data["noOfUndersluiceBaysOrGates"] = this.noOfUndersluiceBaysOrGates;
        data["undersluiceLengthOfEachBayOpening"] = this.undersluiceLengthOfEachBayOpening;
        data["undersluiceCrestElevation"] = this.undersluiceCrestElevation;
        data["barrageNoOfHeadRegulators"] = this.barrageNoOfHeadRegulators;
        data["barrageWidthHeadRegulators"] = this.barrageWidthHeadRegulators;
        data["barrageNoOfHeadRegulatorsBays"] = this.barrageNoOfHeadRegulatorsBays;
        data["barrageWidthOfEachBayOpening"] = this.barrageWidthOfEachBayOpening;
        data["barrageCrestElevation"] = this.barrageCrestElevation;
        data["weirTotalLength"] = this.weirTotalLength;
        data["weirCrestElevation"] = this.weirCrestElevation;
        data["weirNoOfUndersluice"] = this.weirNoOfUndersluice;
        data["weirNoOfUndersluiceBaysOrGates"] = this.weirNoOfUndersluiceBaysOrGates;
        data["weirUndersluiceLengthOfEachBayOpening"] = this.weirUndersluiceLengthOfEachBayOpening;
        data["weirUndersluiceCrestElevation"] = this.weirUndersluiceCrestElevation;
        data["weirNoOfHeadRegulators"] = this.weirNoOfHeadRegulators;
        data["weirWidthHeadRegulators"] = this.weirWidthHeadRegulators;
        data["weirNoOfHeadRegulatorsBays"] = this.weirNoOfHeadRegulatorsBays;
        data["weirWidthOfEachBayOpening"] = this.weirWidthOfEachBayOpening;
        data["weirHeadRegulatorsCrestElevation"] = this.weirHeadRegulatorsCrestElevation;
        data["bankIntakeIsGated"] = this.bankIntakeIsGated;
        data["stillLevelLength"] = this.stillLevelLength;
        data["sizeOfOrificeWidth"] = this.sizeOfOrificeWidth;
        data["sizeOfOrificeHeight"] = this.sizeOfOrificeHeight;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_HeadWork {
        const json = this.toJSON();
        let result = new Dto_HeadWork();
        result.init(json);
        return result;
    }
}

export interface IDto_HeadWork {
    headWorksType: string | undefined;
    headWorksTypeOther: string | undefined;
    barrageTotalLength: number | undefined;
    noOfBaysOrGates: number | undefined;
    lengthOfEachBayOpening: number | undefined;
    crestElevation: number | undefined;
    noOfUndersluice: number | undefined;
    noOfUndersluiceBaysOrGates: number | undefined;
    undersluiceLengthOfEachBayOpening: number | undefined;
    undersluiceCrestElevation: number | undefined;
    barrageNoOfHeadRegulators: number | undefined;
    barrageWidthHeadRegulators: number | undefined;
    barrageNoOfHeadRegulatorsBays: number | undefined;
    barrageWidthOfEachBayOpening: number | undefined;
    barrageCrestElevation: number | undefined;
    weirTotalLength: number | undefined;
    weirCrestElevation: number | undefined;
    weirNoOfUndersluice: number | undefined;
    weirNoOfUndersluiceBaysOrGates: number | undefined;
    weirUndersluiceLengthOfEachBayOpening: number | undefined;
    weirUndersluiceCrestElevation: number | undefined;
    weirNoOfHeadRegulators: number | undefined;
    weirWidthHeadRegulators: number | undefined;
    weirNoOfHeadRegulatorsBays: number | undefined;
    weirWidthOfEachBayOpening: number | undefined;
    weirHeadRegulatorsCrestElevation: number | undefined;
    bankIntakeIsGated: boolean | undefined;
    stillLevelLength: number | undefined;
    sizeOfOrificeWidth: number | undefined;
    sizeOfOrificeHeight: number | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_HeadWork implements IPagedResultDtoOfDto_HeadWork {
    totalCount: number | undefined;
    items: Dto_HeadWork[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_HeadWork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_HeadWork.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_HeadWork {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_HeadWork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_HeadWork {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_HeadWork();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_HeadWork {
    totalCount: number | undefined;
    items: Dto_HeadWork[] | undefined;
}

export class Dto_LocalBodyType implements IDto_LocalBodyType {
    localBodyTypeName: string | undefined;
    status: boolean | undefined;
    id: number | undefined;

    constructor(data?: IDto_LocalBodyType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.localBodyTypeName = data["localBodyTypeName"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_LocalBodyType {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_LocalBodyType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localBodyTypeName"] = this.localBodyTypeName;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_LocalBodyType {
        const json = this.toJSON();
        let result = new Dto_LocalBodyType();
        result.init(json);
        return result;
    }
}

export interface IDto_LocalBodyType {
    localBodyTypeName: string | undefined;
    status: boolean | undefined;
    id: number | undefined;
}

export class Dto_LocalBodyName implements IDto_LocalBodyName {
    localBodyName: string | undefined;
    status: boolean | undefined;
    localBodyTypeId: number | undefined;
    districtId: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_LocalBodyName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.localBodyName = data["localBodyName"];
            this.status = data["status"];
            this.localBodyTypeId = data["localBodyTypeId"];
            this.districtId = data["districtId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_LocalBodyName {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_LocalBodyName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["localBodyName"] = this.localBodyName;
        data["status"] = this.status;
        data["localBodyTypeId"] = this.localBodyTypeId;
        data["districtId"] = this.districtId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_LocalBodyName {
        const json = this.toJSON();
        let result = new Dto_LocalBodyName();
        result.init(json);
        return result;
    }
}

export interface IDto_LocalBodyName {
    localBodyName: string | undefined;
    status: boolean | undefined;
    localBodyTypeId: number | undefined;
    districtId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_LocalBodyName implements IPagedResultDtoOfDto_LocalBodyName {
    totalCount: number | undefined;
    items: Dto_LocalBodyName[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_LocalBodyName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_LocalBodyName.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_LocalBodyName {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_LocalBodyName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_LocalBodyName {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_LocalBodyName();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_LocalBodyName {
    totalCount: number | undefined;
    items: Dto_LocalBodyName[] | undefined;
}

export class PagedResultDtoOfDto_LocalBodyType implements IPagedResultDtoOfDto_LocalBodyType {
    totalCount: number | undefined;
    items: Dto_LocalBodyType[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_LocalBodyType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_LocalBodyType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_LocalBodyType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_LocalBodyType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_LocalBodyType {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_LocalBodyType();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_LocalBodyType {
    totalCount: number | undefined;
    items: Dto_LocalBodyType[] | undefined;
}

export class Dto_LocationProjectRelation implements IDto_LocationProjectRelation {
    projectId: string | undefined;
    locationLocalBodyNameId: number | undefined;
    ward: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_LocationProjectRelation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.locationLocalBodyNameId = data["locationLocalBodyNameId"];
            this.ward = data["ward"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_LocationProjectRelation {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_LocationProjectRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["locationLocalBodyNameId"] = this.locationLocalBodyNameId;
        data["ward"] = this.ward;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_LocationProjectRelation {
        const json = this.toJSON();
        let result = new Dto_LocationProjectRelation();
        result.init(json);
        return result;
    }
}

export interface IDto_LocationProjectRelation {
    projectId: string | undefined;
    locationLocalBodyNameId: number | undefined;
    ward: number | undefined;
    id: number | undefined;
}

export class LocationProjectWardRelationDetailDto implements ILocationProjectWardRelationDetailDto {
    id: number | undefined;
    localBodyTypeId: number | undefined;
    wardName: number | undefined;
    provienceName: string | undefined;
    districtName: string | undefined;
    localBodyTypeName: string | undefined;
    localBodyName: string | undefined;

    constructor(data?: ILocationProjectWardRelationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.localBodyTypeId = data["localBodyTypeId"];
            this.wardName = data["wardName"];
            this.provienceName = data["provienceName"];
            this.districtName = data["districtName"];
            this.localBodyTypeName = data["localBodyTypeName"];
            this.localBodyName = data["localBodyName"];
        }
    }

    static fromJS(data: any): LocationProjectWardRelationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationProjectWardRelationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localBodyTypeId"] = this.localBodyTypeId;
        data["wardName"] = this.wardName;
        data["provienceName"] = this.provienceName;
        data["districtName"] = this.districtName;
        data["localBodyTypeName"] = this.localBodyTypeName;
        data["localBodyName"] = this.localBodyName;
        return data; 
    }

    clone(): LocationProjectWardRelationDetailDto {
        const json = this.toJSON();
        let result = new LocationProjectWardRelationDetailDto();
        result.init(json);
        return result;
    }
}

export interface ILocationProjectWardRelationDetailDto {
    id: number | undefined;
    localBodyTypeId: number | undefined;
    wardName: number | undefined;
    provienceName: string | undefined;
    districtName: string | undefined;
    localBodyTypeName: string | undefined;
    localBodyName: string | undefined;
}

export class PagedResultDtoOfDto_LocationProjectRelation implements IPagedResultDtoOfDto_LocationProjectRelation {
    totalCount: number | undefined;
    items: Dto_LocationProjectRelation[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_LocationProjectRelation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_LocationProjectRelation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_LocationProjectRelation {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_LocationProjectRelation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_LocationProjectRelation {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_LocationProjectRelation();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_LocationProjectRelation {
    totalCount: number | undefined;
    items: Dto_LocationProjectRelation[] | undefined;
}

export class MainCanalViewModel implements IMainCanalViewModel {
    canalStructureDetails: Dto_MainCanalStructureDetailViewModel[] | undefined;
    isCanalDirectionLeft: boolean | undefined;
    idleLength: number | undefined;
    earthenTypeCanalLength: number | undefined;
    earthenSlideSlope: string | undefined;
    linedTypeCanalLength: number | undefined;
    linedSlideSlope: string | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    topWidth: number | undefined;
    slideSlope1: string | undefined;
    bottomWidth: number | undefined;
    earthenLongitudinalSlope: string | undefined;
    linedLongitudinalSlope: string | undefined;
    noOfBranchCanal: number | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IMainCanalViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["canalStructureDetails"] && data["canalStructureDetails"].constructor === Array) {
                this.canalStructureDetails = [];
                for (let item of data["canalStructureDetails"])
                    this.canalStructureDetails.push(Dto_MainCanalStructureDetailViewModel.fromJS(item));
            }
            this.isCanalDirectionLeft = data["isCanalDirectionLeft"];
            this.idleLength = data["idleLength"];
            this.earthenTypeCanalLength = data["earthenTypeCanalLength"];
            this.earthenSlideSlope = data["earthenSlideSlope"];
            this.linedTypeCanalLength = data["linedTypeCanalLength"];
            this.linedSlideSlope = data["linedSlideSlope"];
            this.totalLength = data["totalLength"];
            this.designDischarge = data["designDischarge"];
            this.topWidth = data["topWidth"];
            this.slideSlope1 = data["slideSlope1"];
            this.bottomWidth = data["bottomWidth"];
            this.earthenLongitudinalSlope = data["earthenLongitudinalSlope"];
            this.linedLongitudinalSlope = data["linedLongitudinalSlope"];
            this.noOfBranchCanal = data["noOfBranchCanal"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MainCanalViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new MainCanalViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.canalStructureDetails && this.canalStructureDetails.constructor === Array) {
            data["canalStructureDetails"] = [];
            for (let item of this.canalStructureDetails)
                data["canalStructureDetails"].push(item.toJSON());
        }
        data["isCanalDirectionLeft"] = this.isCanalDirectionLeft;
        data["idleLength"] = this.idleLength;
        data["earthenTypeCanalLength"] = this.earthenTypeCanalLength;
        data["earthenSlideSlope"] = this.earthenSlideSlope;
        data["linedTypeCanalLength"] = this.linedTypeCanalLength;
        data["linedSlideSlope"] = this.linedSlideSlope;
        data["totalLength"] = this.totalLength;
        data["designDischarge"] = this.designDischarge;
        data["topWidth"] = this.topWidth;
        data["slideSlope1"] = this.slideSlope1;
        data["bottomWidth"] = this.bottomWidth;
        data["earthenLongitudinalSlope"] = this.earthenLongitudinalSlope;
        data["linedLongitudinalSlope"] = this.linedLongitudinalSlope;
        data["noOfBranchCanal"] = this.noOfBranchCanal;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MainCanalViewModel {
        const json = this.toJSON();
        let result = new MainCanalViewModel();
        result.init(json);
        return result;
    }
}

export interface IMainCanalViewModel {
    canalStructureDetails: Dto_MainCanalStructureDetailViewModel[] | undefined;
    isCanalDirectionLeft: boolean | undefined;
    idleLength: number | undefined;
    earthenTypeCanalLength: number | undefined;
    earthenSlideSlope: string | undefined;
    linedTypeCanalLength: number | undefined;
    linedSlideSlope: string | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    topWidth: number | undefined;
    slideSlope1: string | undefined;
    bottomWidth: number | undefined;
    earthenLongitudinalSlope: string | undefined;
    linedLongitudinalSlope: string | undefined;
    noOfBranchCanal: number | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class Dto_MainCanalStructureDetailViewModel implements IDto_MainCanalStructureDetailViewModel {
    name: string | undefined;
    mainCanalId: number | undefined;
    mainCanalStructureTypeId: number | undefined;
    noOfStructure: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_MainCanalStructureDetailViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.mainCanalId = data["mainCanalId"];
            this.mainCanalStructureTypeId = data["mainCanalStructureTypeId"];
            this.noOfStructure = data["noOfStructure"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_MainCanalStructureDetailViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_MainCanalStructureDetailViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["mainCanalId"] = this.mainCanalId;
        data["mainCanalStructureTypeId"] = this.mainCanalStructureTypeId;
        data["noOfStructure"] = this.noOfStructure;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_MainCanalStructureDetailViewModel {
        const json = this.toJSON();
        let result = new Dto_MainCanalStructureDetailViewModel();
        result.init(json);
        return result;
    }
}

export interface IDto_MainCanalStructureDetailViewModel {
    name: string | undefined;
    mainCanalId: number | undefined;
    mainCanalStructureTypeId: number | undefined;
    noOfStructure: number | undefined;
    id: number | undefined;
}

export class MainCanalDataModel implements IMainCanalDataModel {
    mainCanalDetail: Dto_MainCanal | undefined;
    canalStructureDetails: Dto_MainCanalStructureDetailViewModel[] | undefined;

    constructor(data?: IMainCanalDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mainCanalDetail = data["mainCanalDetail"] ? Dto_MainCanal.fromJS(data["mainCanalDetail"]) : <any>undefined;
            if (data["canalStructureDetails"] && data["canalStructureDetails"].constructor === Array) {
                this.canalStructureDetails = [];
                for (let item of data["canalStructureDetails"])
                    this.canalStructureDetails.push(Dto_MainCanalStructureDetailViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainCanalDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new MainCanalDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainCanalDetail"] = this.mainCanalDetail ? this.mainCanalDetail.toJSON() : <any>undefined;
        if (this.canalStructureDetails && this.canalStructureDetails.constructor === Array) {
            data["canalStructureDetails"] = [];
            for (let item of this.canalStructureDetails)
                data["canalStructureDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MainCanalDataModel {
        const json = this.toJSON();
        let result = new MainCanalDataModel();
        result.init(json);
        return result;
    }
}

export interface IMainCanalDataModel {
    mainCanalDetail: Dto_MainCanal | undefined;
    canalStructureDetails: Dto_MainCanalStructureDetailViewModel[] | undefined;
}

export class Dto_MainCanal implements IDto_MainCanal {
    isCanalDirectionLeft: boolean | undefined;
    idleLength: number | undefined;
    earthenTypeCanalLength: number | undefined;
    earthenSlideSlope: string | undefined;
    linedTypeCanalLength: number | undefined;
    linedSlideSlope: string | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    topWidth: number | undefined;
    slideSlope1: string | undefined;
    bottomWidth: number | undefined;
    earthenLongitudinalSlope: string | undefined;
    linedLongitudinalSlope: string | undefined;
    noOfBranchCanal: number | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_MainCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isCanalDirectionLeft = data["isCanalDirectionLeft"];
            this.idleLength = data["idleLength"];
            this.earthenTypeCanalLength = data["earthenTypeCanalLength"];
            this.earthenSlideSlope = data["earthenSlideSlope"];
            this.linedTypeCanalLength = data["linedTypeCanalLength"];
            this.linedSlideSlope = data["linedSlideSlope"];
            this.totalLength = data["totalLength"];
            this.designDischarge = data["designDischarge"];
            this.topWidth = data["topWidth"];
            this.slideSlope1 = data["slideSlope1"];
            this.bottomWidth = data["bottomWidth"];
            this.earthenLongitudinalSlope = data["earthenLongitudinalSlope"];
            this.linedLongitudinalSlope = data["linedLongitudinalSlope"];
            this.noOfBranchCanal = data["noOfBranchCanal"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_MainCanal {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_MainCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCanalDirectionLeft"] = this.isCanalDirectionLeft;
        data["idleLength"] = this.idleLength;
        data["earthenTypeCanalLength"] = this.earthenTypeCanalLength;
        data["earthenSlideSlope"] = this.earthenSlideSlope;
        data["linedTypeCanalLength"] = this.linedTypeCanalLength;
        data["linedSlideSlope"] = this.linedSlideSlope;
        data["totalLength"] = this.totalLength;
        data["designDischarge"] = this.designDischarge;
        data["topWidth"] = this.topWidth;
        data["slideSlope1"] = this.slideSlope1;
        data["bottomWidth"] = this.bottomWidth;
        data["earthenLongitudinalSlope"] = this.earthenLongitudinalSlope;
        data["linedLongitudinalSlope"] = this.linedLongitudinalSlope;
        data["noOfBranchCanal"] = this.noOfBranchCanal;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_MainCanal {
        const json = this.toJSON();
        let result = new Dto_MainCanal();
        result.init(json);
        return result;
    }
}

export interface IDto_MainCanal {
    isCanalDirectionLeft: boolean | undefined;
    idleLength: number | undefined;
    earthenTypeCanalLength: number | undefined;
    earthenSlideSlope: string | undefined;
    linedTypeCanalLength: number | undefined;
    linedSlideSlope: string | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    topWidth: number | undefined;
    slideSlope1: string | undefined;
    bottomWidth: number | undefined;
    earthenLongitudinalSlope: string | undefined;
    linedLongitudinalSlope: string | undefined;
    noOfBranchCanal: number | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_MainCanal implements IPagedResultDtoOfDto_MainCanal {
    totalCount: number | undefined;
    items: Dto_MainCanal[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_MainCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_MainCanal.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_MainCanal {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_MainCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_MainCanal {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_MainCanal();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_MainCanal {
    totalCount: number | undefined;
    items: Dto_MainCanal[] | undefined;
}

export class PagedResultDtoOfDto_MainCanalStructureType implements IPagedResultDtoOfDto_MainCanalStructureType {
    totalCount: number | undefined;
    items: Dto_MainCanalStructureType[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_MainCanalStructureType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_MainCanalStructureType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_MainCanalStructureType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_MainCanalStructureType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_MainCanalStructureType {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_MainCanalStructureType();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_MainCanalStructureType {
    totalCount: number | undefined;
    items: Dto_MainCanalStructureType[] | undefined;
}

export class Dto_MainCanalStructureType implements IDto_MainCanalStructureType {
    name: string | undefined;
    orderNo: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_MainCanalStructureType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.orderNo = data["orderNo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_MainCanalStructureType {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_MainCanalStructureType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNo"] = this.orderNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_MainCanalStructureType {
        const json = this.toJSON();
        let result = new Dto_MainCanalStructureType();
        result.init(json);
        return result;
    }
}

export interface IDto_MainCanalStructureType {
    name: string | undefined;
    orderNo: number | undefined;
    id: number | undefined;
}

export class Dto_ProgramInformation implements IDto_ProgramInformation {
    name: string;
    code: string;
    orderNo: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_ProgramInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.code = data["code"];
            this.orderNo = data["orderNo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_ProgramInformation {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_ProgramInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["orderNo"] = this.orderNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_ProgramInformation {
        const json = this.toJSON();
        let result = new Dto_ProgramInformation();
        result.init(json);
        return result;
    }
}

export interface IDto_ProgramInformation {
    name: string;
    code: string;
    orderNo: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_ProgramInformation implements IPagedResultDtoOfDto_ProgramInformation {
    totalCount: number | undefined;
    items: Dto_ProgramInformation[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_ProgramInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_ProgramInformation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_ProgramInformation {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_ProgramInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_ProgramInformation {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_ProgramInformation();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_ProgramInformation {
    totalCount: number | undefined;
    items: Dto_ProgramInformation[] | undefined;
}

export class Dto_ProgramType implements IDto_ProgramType {
    name: string;
    orderNo: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_ProgramType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.orderNo = data["orderNo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_ProgramType {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_ProgramType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNo"] = this.orderNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_ProgramType {
        const json = this.toJSON();
        let result = new Dto_ProgramType();
        result.init(json);
        return result;
    }
}

export interface IDto_ProgramType {
    name: string;
    orderNo: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_ProgramType implements IPagedResultDtoOfDto_ProgramType {
    totalCount: number | undefined;
    items: Dto_ProgramType[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_ProgramType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_ProgramType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_ProgramType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_ProgramType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_ProgramType {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_ProgramType();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_ProgramType {
    totalCount: number | undefined;
    items: Dto_ProgramType[] | undefined;
}

export class PagedResultDtoOfDto_Project implements IPagedResultDtoOfDto_Project {
    totalCount: number | undefined;
    items: Dto_Project[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_Project) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_Project.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_Project {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_Project {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_Project();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_Project {
    totalCount: number | undefined;
    items: Dto_Project[] | undefined;
}

export class Dto_Project implements IDto_Project {
    name: string;
    id: string | undefined;

    constructor(data?: IDto_Project) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_Project {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_Project {
        const json = this.toJSON();
        let result = new Dto_Project();
        result.init(json);
        return result;
    }
}

export interface IDto_Project {
    name: string;
    id: string | undefined;
}

export class PagedResultDtoOfDto_ProjectUserCount implements IPagedResultDtoOfDto_ProjectUserCount {
    totalCount: number | undefined;
    items: Dto_ProjectUserCount[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_ProjectUserCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_ProjectUserCount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_ProjectUserCount {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_ProjectUserCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_ProjectUserCount {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_ProjectUserCount();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_ProjectUserCount {
    totalCount: number | undefined;
    items: Dto_ProjectUserCount[] | undefined;
}

export class Dto_ProjectUserCount implements IDto_ProjectUserCount {
    name: string | undefined;
    id: string | undefined;
    counts: number | undefined;

    constructor(data?: IDto_ProjectUserCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.id = data["id"];
            this.counts = data["counts"];
        }
    }

    static fromJS(data: any): Dto_ProjectUserCount {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_ProjectUserCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        data["counts"] = this.counts;
        return data; 
    }

    clone(): Dto_ProjectUserCount {
        const json = this.toJSON();
        let result = new Dto_ProjectUserCount();
        result.init(json);
        return result;
    }
}

export interface IDto_ProjectUserCount {
    name: string | undefined;
    id: string | undefined;
    counts: number | undefined;
}

export class PagedResultDtoOfDto_UserProjectViewModel implements IPagedResultDtoOfDto_UserProjectViewModel {
    totalCount: number | undefined;
    items: Dto_UserProjectViewModel[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_UserProjectViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_UserProjectViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_UserProjectViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_UserProjectViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_UserProjectViewModel {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_UserProjectViewModel();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_UserProjectViewModel {
    totalCount: number | undefined;
    items: Dto_UserProjectViewModel[] | undefined;
}

export class Dto_UserProjectViewModel implements IDto_UserProjectViewModel {
    projectName: string | undefined;
    userFirstName: string | undefined;
    userEmail: string | undefined;
    userLastName: string | undefined;
    userFullName: string | undefined;
    projectId: string | undefined;
    userId: number | undefined;

    constructor(data?: IDto_UserProjectViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectName = data["projectName"];
            this.userFirstName = data["userFirstName"];
            this.userEmail = data["userEmail"];
            this.userLastName = data["userLastName"];
            this.userFullName = data["userFullName"];
            this.projectId = data["projectId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): Dto_UserProjectViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_UserProjectViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName;
        data["userFirstName"] = this.userFirstName;
        data["userEmail"] = this.userEmail;
        data["userLastName"] = this.userLastName;
        data["userFullName"] = this.userFullName;
        data["projectId"] = this.projectId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): Dto_UserProjectViewModel {
        const json = this.toJSON();
        let result = new Dto_UserProjectViewModel();
        result.init(json);
        return result;
    }
}

export interface IDto_UserProjectViewModel {
    projectName: string | undefined;
    userFirstName: string | undefined;
    userEmail: string | undefined;
    userLastName: string | undefined;
    userFullName: string | undefined;
    projectId: string | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfDto_UserProjectViewModel implements IListResultDtoOfDto_UserProjectViewModel {
    items: Dto_UserProjectViewModel[] | undefined;

    constructor(data?: IListResultDtoOfDto_UserProjectViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_UserProjectViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDto_UserProjectViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDto_UserProjectViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfDto_UserProjectViewModel {
        const json = this.toJSON();
        let result = new ListResultDtoOfDto_UserProjectViewModel();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfDto_UserProjectViewModel {
    items: Dto_UserProjectViewModel[] | undefined;
}

export class Dto_ProjectInfo implements IDto_ProjectInfo {
    commandarea_gca: number | undefined;
    commandarea_nca: number | undefined;
    mgmt_system: string | undefined;
    mgmt_system_other: string | undefined;
    project_type: string | undefined;
    project_comment: string | undefined;
    other_info_prepared_by: string | undefined;
    other_info_approved_by: string | undefined;
    other_info_recommended_by: string | undefined;
    donarCountriesName: string | undefined;
    donarCountriesOthersName: string | undefined;
    isPhaseCompleted: boolean | undefined;
    approved_date: moment.Moment | undefined;
    start_date: moment.Moment | undefined;
    end_date: moment.Moment | undefined;
    programInformationId: number | undefined;
    programTypeId: number | undefined;
    projectStatusId: number | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_ProjectInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commandarea_gca = data["commandarea_gca"];
            this.commandarea_nca = data["commandarea_nca"];
            this.mgmt_system = data["mgmt_system"];
            this.mgmt_system_other = data["mgmt_system_other"];
            this.project_type = data["project_type"];
            this.project_comment = data["project_comment"];
            this.other_info_prepared_by = data["other_info_prepared_by"];
            this.other_info_approved_by = data["other_info_approved_by"];
            this.other_info_recommended_by = data["other_info_recommended_by"];
            this.donarCountriesName = data["donarCountriesName"];
            this.donarCountriesOthersName = data["donarCountriesOthersName"];
            this.isPhaseCompleted = data["isPhaseCompleted"];
            this.approved_date = data["approved_date"] ? moment(data["approved_date"].toString()) : <any>undefined;
            this.start_date = data["start_date"] ? moment(data["start_date"].toString()) : <any>undefined;
            this.end_date = data["end_date"] ? moment(data["end_date"].toString()) : <any>undefined;
            this.programInformationId = data["programInformationId"];
            this.programTypeId = data["programTypeId"];
            this.projectStatusId = data["projectStatusId"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_ProjectInfo {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_ProjectInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandarea_gca"] = this.commandarea_gca;
        data["commandarea_nca"] = this.commandarea_nca;
        data["mgmt_system"] = this.mgmt_system;
        data["mgmt_system_other"] = this.mgmt_system_other;
        data["project_type"] = this.project_type;
        data["project_comment"] = this.project_comment;
        data["other_info_prepared_by"] = this.other_info_prepared_by;
        data["other_info_approved_by"] = this.other_info_approved_by;
        data["other_info_recommended_by"] = this.other_info_recommended_by;
        data["donarCountriesName"] = this.donarCountriesName;
        data["donarCountriesOthersName"] = this.donarCountriesOthersName;
        data["isPhaseCompleted"] = this.isPhaseCompleted;
        data["approved_date"] = this.approved_date ? this.approved_date.toISOString() : <any>undefined;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["end_date"] = this.end_date ? this.end_date.toISOString() : <any>undefined;
        data["programInformationId"] = this.programInformationId;
        data["programTypeId"] = this.programTypeId;
        data["projectStatusId"] = this.projectStatusId;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_ProjectInfo {
        const json = this.toJSON();
        let result = new Dto_ProjectInfo();
        result.init(json);
        return result;
    }
}

export interface IDto_ProjectInfo {
    commandarea_gca: number | undefined;
    commandarea_nca: number | undefined;
    mgmt_system: string | undefined;
    mgmt_system_other: string | undefined;
    project_type: string | undefined;
    project_comment: string | undefined;
    other_info_prepared_by: string | undefined;
    other_info_approved_by: string | undefined;
    other_info_recommended_by: string | undefined;
    donarCountriesName: string | undefined;
    donarCountriesOthersName: string | undefined;
    isPhaseCompleted: boolean | undefined;
    approved_date: moment.Moment | undefined;
    start_date: moment.Moment | undefined;
    end_date: moment.Moment | undefined;
    programInformationId: number | undefined;
    programTypeId: number | undefined;
    projectStatusId: number | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class ProjectInformationInitals implements IProjectInformationInitals {
    programTypeList: Dto_ProgramType[] | undefined;
    programInformationList: Dto_ProgramInformation[] | undefined;
    projectStatusList: Dto_ProjectStatus[] | undefined;

    constructor(data?: IProjectInformationInitals) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["programTypeList"] && data["programTypeList"].constructor === Array) {
                this.programTypeList = [];
                for (let item of data["programTypeList"])
                    this.programTypeList.push(Dto_ProgramType.fromJS(item));
            }
            if (data["programInformationList"] && data["programInformationList"].constructor === Array) {
                this.programInformationList = [];
                for (let item of data["programInformationList"])
                    this.programInformationList.push(Dto_ProgramInformation.fromJS(item));
            }
            if (data["projectStatusList"] && data["projectStatusList"].constructor === Array) {
                this.projectStatusList = [];
                for (let item of data["projectStatusList"])
                    this.projectStatusList.push(Dto_ProjectStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectInformationInitals {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectInformationInitals();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.programTypeList && this.programTypeList.constructor === Array) {
            data["programTypeList"] = [];
            for (let item of this.programTypeList)
                data["programTypeList"].push(item.toJSON());
        }
        if (this.programInformationList && this.programInformationList.constructor === Array) {
            data["programInformationList"] = [];
            for (let item of this.programInformationList)
                data["programInformationList"].push(item.toJSON());
        }
        if (this.projectStatusList && this.projectStatusList.constructor === Array) {
            data["projectStatusList"] = [];
            for (let item of this.projectStatusList)
                data["projectStatusList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ProjectInformationInitals {
        const json = this.toJSON();
        let result = new ProjectInformationInitals();
        result.init(json);
        return result;
    }
}

export interface IProjectInformationInitals {
    programTypeList: Dto_ProgramType[] | undefined;
    programInformationList: Dto_ProgramInformation[] | undefined;
    projectStatusList: Dto_ProjectStatus[] | undefined;
}

export class Dto_ProjectStatus implements IDto_ProjectStatus {
    name: string | undefined;
    orderNo: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_ProjectStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.orderNo = data["orderNo"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_ProjectStatus {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_ProjectStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["orderNo"] = this.orderNo;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_ProjectStatus {
        const json = this.toJSON();
        let result = new Dto_ProjectStatus();
        result.init(json);
        return result;
    }
}

export interface IDto_ProjectStatus {
    name: string | undefined;
    orderNo: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_ProjectInfo implements IPagedResultDtoOfDto_ProjectInfo {
    totalCount: number | undefined;
    items: Dto_ProjectInfo[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_ProjectInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_ProjectInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_ProjectInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_ProjectInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_ProjectInfo {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_ProjectInfo();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_ProjectInfo {
    totalCount: number | undefined;
    items: Dto_ProjectInfo[] | undefined;
}

export class Dto_MajorRiverBasin implements IDto_MajorRiverBasin {
    riverBasinName: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_MajorRiverBasin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.riverBasinName = data["riverBasinName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_MajorRiverBasin {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_MajorRiverBasin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["riverBasinName"] = this.riverBasinName;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_MajorRiverBasin {
        const json = this.toJSON();
        let result = new Dto_MajorRiverBasin();
        result.init(json);
        return result;
    }
}

export interface IDto_MajorRiverBasin {
    riverBasinName: string | undefined;
    id: number | undefined;
}

export class Dto_LocationInfo implements IDto_LocationInfo {
    ecologicalRegion: string | undefined;
    nearestRoad: string | undefined;
    roadDistance: number | undefined;
    airportDistance: number | undefined;
    airport: string | undefined;
    marketDistance: number | undefined;
    market: string | undefined;
    localRiverBasin: string | undefined;
    riverSource: string | undefined;
    projectId: string | undefined;
    majorRiverBasinId: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_LocationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ecologicalRegion = data["ecologicalRegion"];
            this.nearestRoad = data["nearestRoad"];
            this.roadDistance = data["roadDistance"];
            this.airportDistance = data["airportDistance"];
            this.airport = data["airport"];
            this.marketDistance = data["marketDistance"];
            this.market = data["market"];
            this.localRiverBasin = data["localRiverBasin"];
            this.riverSource = data["riverSource"];
            this.projectId = data["projectId"];
            this.majorRiverBasinId = data["majorRiverBasinId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_LocationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_LocationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ecologicalRegion"] = this.ecologicalRegion;
        data["nearestRoad"] = this.nearestRoad;
        data["roadDistance"] = this.roadDistance;
        data["airportDistance"] = this.airportDistance;
        data["airport"] = this.airport;
        data["marketDistance"] = this.marketDistance;
        data["market"] = this.market;
        data["localRiverBasin"] = this.localRiverBasin;
        data["riverSource"] = this.riverSource;
        data["projectId"] = this.projectId;
        data["majorRiverBasinId"] = this.majorRiverBasinId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_LocationInfo {
        const json = this.toJSON();
        let result = new Dto_LocationInfo();
        result.init(json);
        return result;
    }
}

export interface IDto_LocationInfo {
    ecologicalRegion: string | undefined;
    nearestRoad: string | undefined;
    roadDistance: number | undefined;
    airportDistance: number | undefined;
    airport: string | undefined;
    marketDistance: number | undefined;
    market: string | undefined;
    localRiverBasin: string | undefined;
    riverSource: string | undefined;
    projectId: string | undefined;
    majorRiverBasinId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_LocationInfo implements IPagedResultDtoOfDto_LocationInfo {
    totalCount: number | undefined;
    items: Dto_LocationInfo[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_LocationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_LocationInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_LocationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_LocationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_LocationInfo {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_LocationInfo();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_LocationInfo {
    totalCount: number | undefined;
    items: Dto_LocationInfo[] | undefined;
}

export class PagedResultDtoOfDto_ProjectStatus implements IPagedResultDtoOfDto_ProjectStatus {
    totalCount: number | undefined;
    items: Dto_ProjectStatus[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_ProjectStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_ProjectStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_ProjectStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_ProjectStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_ProjectStatus {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_ProjectStatus();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_ProjectStatus {
    totalCount: number | undefined;
    items: Dto_ProjectStatus[] | undefined;
}

export class PagedResultDtoOfDto_Provience implements IPagedResultDtoOfDto_Provience {
    totalCount: number | undefined;
    items: Dto_Provience[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_Provience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_Provience.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_Provience {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_Provience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_Provience {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_Provience();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_Provience {
    totalCount: number | undefined;
    items: Dto_Provience[] | undefined;
}

export class Dto_Provience implements IDto_Provience {
    provienceName: string | undefined;
    status: boolean | undefined;
    id: number | undefined;

    constructor(data?: IDto_Provience) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.provienceName = data["provienceName"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_Provience {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_Provience();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provienceName"] = this.provienceName;
        data["status"] = this.status;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_Provience {
        const json = this.toJSON();
        let result = new Dto_Provience();
        result.init(json);
        return result;
    }
}

export interface IDto_Provience {
    provienceName: string | undefined;
    status: boolean | undefined;
    id: number | undefined;
}

export class Dto_RiverHydrology implements IDto_RiverHydrology {
    catchmentArea: number | undefined;
    riverWidthAtHeadWorkSite: number | undefined;
    longitudinalSlopeOfRiver: string | undefined;
    averageAnnualRiverfall: number | undefined;
    floodDischarge25yrs: number | undefined;
    floodDischarge50yrs: number | undefined;
    floodDischarge100yrs: number | undefined;
    floodDischarge500yrs: number | undefined;
    floodDischarge1000yrs: number | undefined;
    pmf: number | undefined;
    methodOfFloodCalculations: string | undefined;
    basinType: string | undefined;
    mipHydrologyRegion: number | undefined;
    projectId: string | undefined;
    designFloodDischarge: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_RiverHydrology) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.catchmentArea = data["catchmentArea"];
            this.riverWidthAtHeadWorkSite = data["riverWidthAtHeadWorkSite"];
            this.longitudinalSlopeOfRiver = data["longitudinalSlopeOfRiver"];
            this.averageAnnualRiverfall = data["averageAnnualRiverfall"];
            this.floodDischarge25yrs = data["floodDischarge25yrs"];
            this.floodDischarge50yrs = data["floodDischarge50yrs"];
            this.floodDischarge100yrs = data["floodDischarge100yrs"];
            this.floodDischarge500yrs = data["floodDischarge500yrs"];
            this.floodDischarge1000yrs = data["floodDischarge1000yrs"];
            this.pmf = data["pmf"];
            this.methodOfFloodCalculations = data["methodOfFloodCalculations"];
            this.basinType = data["basinType"];
            this.mipHydrologyRegion = data["mipHydrologyRegion"];
            this.projectId = data["projectId"];
            this.designFloodDischarge = data["designFloodDischarge"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_RiverHydrology {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_RiverHydrology();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catchmentArea"] = this.catchmentArea;
        data["riverWidthAtHeadWorkSite"] = this.riverWidthAtHeadWorkSite;
        data["longitudinalSlopeOfRiver"] = this.longitudinalSlopeOfRiver;
        data["averageAnnualRiverfall"] = this.averageAnnualRiverfall;
        data["floodDischarge25yrs"] = this.floodDischarge25yrs;
        data["floodDischarge50yrs"] = this.floodDischarge50yrs;
        data["floodDischarge100yrs"] = this.floodDischarge100yrs;
        data["floodDischarge500yrs"] = this.floodDischarge500yrs;
        data["floodDischarge1000yrs"] = this.floodDischarge1000yrs;
        data["pmf"] = this.pmf;
        data["methodOfFloodCalculations"] = this.methodOfFloodCalculations;
        data["basinType"] = this.basinType;
        data["mipHydrologyRegion"] = this.mipHydrologyRegion;
        data["projectId"] = this.projectId;
        data["designFloodDischarge"] = this.designFloodDischarge;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_RiverHydrology {
        const json = this.toJSON();
        let result = new Dto_RiverHydrology();
        result.init(json);
        return result;
    }
}

export interface IDto_RiverHydrology {
    catchmentArea: number | undefined;
    riverWidthAtHeadWorkSite: number | undefined;
    longitudinalSlopeOfRiver: string | undefined;
    averageAnnualRiverfall: number | undefined;
    floodDischarge25yrs: number | undefined;
    floodDischarge50yrs: number | undefined;
    floodDischarge100yrs: number | undefined;
    floodDischarge500yrs: number | undefined;
    floodDischarge1000yrs: number | undefined;
    pmf: number | undefined;
    methodOfFloodCalculations: string | undefined;
    basinType: string | undefined;
    mipHydrologyRegion: number | undefined;
    projectId: string | undefined;
    designFloodDischarge: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_RiverHydrology implements IPagedResultDtoOfDto_RiverHydrology {
    totalCount: number | undefined;
    items: Dto_RiverHydrology[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_RiverHydrology) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_RiverHydrology.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_RiverHydrology {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_RiverHydrology();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_RiverHydrology {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_RiverHydrology();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_RiverHydrology {
    totalCount: number | undefined;
    items: Dto_RiverHydrology[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
    id: number | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    permissions: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean | undefined;
    id: number | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;
}

export class Dto_SecondaryCanal implements IDto_SecondaryCanal {
    name: string | undefined;
    gca: number | undefined;
    cca: number | undefined;
    unlinedTypeCanalLength: number | undefined;
    linedTypeCanalLength: number | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    canalStructure: string | undefined;
    noOfTertiaryCanal: number | undefined;
    branchCanalId: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_SecondaryCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.gca = data["gca"];
            this.cca = data["cca"];
            this.unlinedTypeCanalLength = data["unlinedTypeCanalLength"];
            this.linedTypeCanalLength = data["linedTypeCanalLength"];
            this.totalLength = data["totalLength"];
            this.designDischarge = data["designDischarge"];
            this.canalStructure = data["canalStructure"];
            this.noOfTertiaryCanal = data["noOfTertiaryCanal"];
            this.branchCanalId = data["branchCanalId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_SecondaryCanal {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_SecondaryCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["gca"] = this.gca;
        data["cca"] = this.cca;
        data["unlinedTypeCanalLength"] = this.unlinedTypeCanalLength;
        data["linedTypeCanalLength"] = this.linedTypeCanalLength;
        data["totalLength"] = this.totalLength;
        data["designDischarge"] = this.designDischarge;
        data["canalStructure"] = this.canalStructure;
        data["noOfTertiaryCanal"] = this.noOfTertiaryCanal;
        data["branchCanalId"] = this.branchCanalId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_SecondaryCanal {
        const json = this.toJSON();
        let result = new Dto_SecondaryCanal();
        result.init(json);
        return result;
    }
}

export interface IDto_SecondaryCanal {
    name: string | undefined;
    gca: number | undefined;
    cca: number | undefined;
    unlinedTypeCanalLength: number | undefined;
    linedTypeCanalLength: number | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    canalStructure: string | undefined;
    noOfTertiaryCanal: number | undefined;
    branchCanalId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_SecondaryCanal implements IPagedResultDtoOfDto_SecondaryCanal {
    totalCount: number | undefined;
    items: Dto_SecondaryCanal[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_SecondaryCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_SecondaryCanal.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_SecondaryCanal {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_SecondaryCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_SecondaryCanal {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_SecondaryCanal();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_SecondaryCanal {
    totalCount: number | undefined;
    items: Dto_SecondaryCanal[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class Dto_SocialInfoDetailListModel implements IDto_SocialInfoDetailListModel {
    id: number | undefined;
    yearOfSurvey: number | undefined;
    noOfHousehold: number | undefined;
    womenHeadedHouseHold: number | undefined;
    female: number | undefined;
    male: number | undefined;
    totalPopulation: number | undefined;
    majorSourceOfIncome: string | undefined;
    annualIncomePerFamily: number | undefined;
    annualIncomePerAgriculture: number | undefined;
    annualIncomePerOtherSrcs: number | undefined;
    literacyRate: number | undefined;
    femaleLiteracyRate: number | undefined;
    maleLiteracyRate: number | undefined;
    annualPopMigrationIn: number | undefined;
    annualPopMigrationOut: number | undefined;
    landOwners: number | undefined;
    landOwnersPercent: number | undefined;
    tenants: number | undefined;
    tenantsPercent: number | undefined;
    ownerWithTenants: number | undefined;
    ownerWithTenantsPercent: number | undefined;
    landless: number | undefined;
    landlessPercent: number | undefined;
    farmSizeSmall: number | undefined;
    farmSizeMedium: number | undefined;
    farmSizeLarge: number | undefined;
    farmSizeVeryLarge: number | undefined;
    farmSizeSmallPercent: number | undefined;
    farmSizeMediumPercent: number | undefined;
    farmSizeLargePercent: number | undefined;
    farmSizeVeryLargePercent: number | undefined;
    foodSufficiency: string | undefined;
    foodSufficiencMonth: number | undefined;
    projectId: string | undefined;
    ethicsGroupData: Dto_EthicsDataViewModel[] | undefined;
    averageFamilySize: number | undefined;
    averageAnnualIncomePerFamily: number | undefined;

    constructor(data?: IDto_SocialInfoDetailListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.yearOfSurvey = data["yearOfSurvey"];
            this.noOfHousehold = data["noOfHousehold"];
            this.womenHeadedHouseHold = data["womenHeadedHouseHold"];
            this.female = data["female"];
            this.male = data["male"];
            this.totalPopulation = data["totalPopulation"];
            this.majorSourceOfIncome = data["majorSourceOfIncome"];
            this.annualIncomePerFamily = data["annualIncomePerFamily"];
            this.annualIncomePerAgriculture = data["annualIncomePerAgriculture"];
            this.annualIncomePerOtherSrcs = data["annualIncomePerOtherSrcs"];
            this.literacyRate = data["literacyRate"];
            this.femaleLiteracyRate = data["femaleLiteracyRate"];
            this.maleLiteracyRate = data["maleLiteracyRate"];
            this.annualPopMigrationIn = data["annualPopMigrationIn"];
            this.annualPopMigrationOut = data["annualPopMigrationOut"];
            this.landOwners = data["landOwners"];
            this.landOwnersPercent = data["landOwnersPercent"];
            this.tenants = data["tenants"];
            this.tenantsPercent = data["tenantsPercent"];
            this.ownerWithTenants = data["ownerWithTenants"];
            this.ownerWithTenantsPercent = data["ownerWithTenantsPercent"];
            this.landless = data["landless"];
            this.landlessPercent = data["landlessPercent"];
            this.farmSizeSmall = data["farmSizeSmall"];
            this.farmSizeMedium = data["farmSizeMedium"];
            this.farmSizeLarge = data["farmSizeLarge"];
            this.farmSizeVeryLarge = data["farmSizeVeryLarge"];
            this.farmSizeSmallPercent = data["farmSizeSmallPercent"];
            this.farmSizeMediumPercent = data["farmSizeMediumPercent"];
            this.farmSizeLargePercent = data["farmSizeLargePercent"];
            this.farmSizeVeryLargePercent = data["farmSizeVeryLargePercent"];
            this.foodSufficiency = data["foodSufficiency"];
            this.foodSufficiencMonth = data["foodSufficiencMonth"];
            this.projectId = data["projectId"];
            if (data["ethicsGroupData"] && data["ethicsGroupData"].constructor === Array) {
                this.ethicsGroupData = [];
                for (let item of data["ethicsGroupData"])
                    this.ethicsGroupData.push(Dto_EthicsDataViewModel.fromJS(item));
            }
            this.averageFamilySize = data["averageFamilySize"];
            this.averageAnnualIncomePerFamily = data["averageAnnualIncomePerFamily"];
        }
    }

    static fromJS(data: any): Dto_SocialInfoDetailListModel {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_SocialInfoDetailListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["yearOfSurvey"] = this.yearOfSurvey;
        data["noOfHousehold"] = this.noOfHousehold;
        data["womenHeadedHouseHold"] = this.womenHeadedHouseHold;
        data["female"] = this.female;
        data["male"] = this.male;
        data["totalPopulation"] = this.totalPopulation;
        data["majorSourceOfIncome"] = this.majorSourceOfIncome;
        data["annualIncomePerFamily"] = this.annualIncomePerFamily;
        data["annualIncomePerAgriculture"] = this.annualIncomePerAgriculture;
        data["annualIncomePerOtherSrcs"] = this.annualIncomePerOtherSrcs;
        data["literacyRate"] = this.literacyRate;
        data["femaleLiteracyRate"] = this.femaleLiteracyRate;
        data["maleLiteracyRate"] = this.maleLiteracyRate;
        data["annualPopMigrationIn"] = this.annualPopMigrationIn;
        data["annualPopMigrationOut"] = this.annualPopMigrationOut;
        data["landOwners"] = this.landOwners;
        data["landOwnersPercent"] = this.landOwnersPercent;
        data["tenants"] = this.tenants;
        data["tenantsPercent"] = this.tenantsPercent;
        data["ownerWithTenants"] = this.ownerWithTenants;
        data["ownerWithTenantsPercent"] = this.ownerWithTenantsPercent;
        data["landless"] = this.landless;
        data["landlessPercent"] = this.landlessPercent;
        data["farmSizeSmall"] = this.farmSizeSmall;
        data["farmSizeMedium"] = this.farmSizeMedium;
        data["farmSizeLarge"] = this.farmSizeLarge;
        data["farmSizeVeryLarge"] = this.farmSizeVeryLarge;
        data["farmSizeSmallPercent"] = this.farmSizeSmallPercent;
        data["farmSizeMediumPercent"] = this.farmSizeMediumPercent;
        data["farmSizeLargePercent"] = this.farmSizeLargePercent;
        data["farmSizeVeryLargePercent"] = this.farmSizeVeryLargePercent;
        data["foodSufficiency"] = this.foodSufficiency;
        data["foodSufficiencMonth"] = this.foodSufficiencMonth;
        data["projectId"] = this.projectId;
        if (this.ethicsGroupData && this.ethicsGroupData.constructor === Array) {
            data["ethicsGroupData"] = [];
            for (let item of this.ethicsGroupData)
                data["ethicsGroupData"].push(item.toJSON());
        }
        data["averageFamilySize"] = this.averageFamilySize;
        data["averageAnnualIncomePerFamily"] = this.averageAnnualIncomePerFamily;
        return data; 
    }

    clone(): Dto_SocialInfoDetailListModel {
        const json = this.toJSON();
        let result = new Dto_SocialInfoDetailListModel();
        result.init(json);
        return result;
    }
}

export interface IDto_SocialInfoDetailListModel {
    id: number | undefined;
    yearOfSurvey: number | undefined;
    noOfHousehold: number | undefined;
    womenHeadedHouseHold: number | undefined;
    female: number | undefined;
    male: number | undefined;
    totalPopulation: number | undefined;
    majorSourceOfIncome: string | undefined;
    annualIncomePerFamily: number | undefined;
    annualIncomePerAgriculture: number | undefined;
    annualIncomePerOtherSrcs: number | undefined;
    literacyRate: number | undefined;
    femaleLiteracyRate: number | undefined;
    maleLiteracyRate: number | undefined;
    annualPopMigrationIn: number | undefined;
    annualPopMigrationOut: number | undefined;
    landOwners: number | undefined;
    landOwnersPercent: number | undefined;
    tenants: number | undefined;
    tenantsPercent: number | undefined;
    ownerWithTenants: number | undefined;
    ownerWithTenantsPercent: number | undefined;
    landless: number | undefined;
    landlessPercent: number | undefined;
    farmSizeSmall: number | undefined;
    farmSizeMedium: number | undefined;
    farmSizeLarge: number | undefined;
    farmSizeVeryLarge: number | undefined;
    farmSizeSmallPercent: number | undefined;
    farmSizeMediumPercent: number | undefined;
    farmSizeLargePercent: number | undefined;
    farmSizeVeryLargePercent: number | undefined;
    foodSufficiency: string | undefined;
    foodSufficiencMonth: number | undefined;
    projectId: string | undefined;
    ethicsGroupData: Dto_EthicsDataViewModel[] | undefined;
    averageFamilySize: number | undefined;
    averageAnnualIncomePerFamily: number | undefined;
}

export class Dto_EthicsDataViewModel implements IDto_EthicsDataViewModel {
    id: number | undefined;
    ethicsGroupId: number | undefined;
    ethicsGroupName: string | undefined;
    socialInfoId: number | undefined;
    noOfPeople: number | undefined;
    noOfPeoplePercent: number | undefined;

    constructor(data?: IDto_EthicsDataViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ethicsGroupId = data["ethicsGroupId"];
            this.ethicsGroupName = data["ethicsGroupName"];
            this.socialInfoId = data["socialInfoId"];
            this.noOfPeople = data["noOfPeople"];
            this.noOfPeoplePercent = data["noOfPeoplePercent"];
        }
    }

    static fromJS(data: any): Dto_EthicsDataViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_EthicsDataViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ethicsGroupId"] = this.ethicsGroupId;
        data["ethicsGroupName"] = this.ethicsGroupName;
        data["socialInfoId"] = this.socialInfoId;
        data["noOfPeople"] = this.noOfPeople;
        data["noOfPeoplePercent"] = this.noOfPeoplePercent;
        return data; 
    }

    clone(): Dto_EthicsDataViewModel {
        const json = this.toJSON();
        let result = new Dto_EthicsDataViewModel();
        result.init(json);
        return result;
    }
}

export interface IDto_EthicsDataViewModel {
    id: number | undefined;
    ethicsGroupId: number | undefined;
    ethicsGroupName: string | undefined;
    socialInfoId: number | undefined;
    noOfPeople: number | undefined;
    noOfPeoplePercent: number | undefined;
}

export class Dto_SocialInfoDataModel implements IDto_SocialInfoDataModel {
    socialInfoDataModel: Dto_SocialInfo | undefined;
    ethicsDataModel: Dto_EthicsDataViewModel[] | undefined;

    constructor(data?: IDto_SocialInfoDataModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.socialInfoDataModel = data["socialInfoDataModel"] ? Dto_SocialInfo.fromJS(data["socialInfoDataModel"]) : <any>undefined;
            if (data["ethicsDataModel"] && data["ethicsDataModel"].constructor === Array) {
                this.ethicsDataModel = [];
                for (let item of data["ethicsDataModel"])
                    this.ethicsDataModel.push(Dto_EthicsDataViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dto_SocialInfoDataModel {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_SocialInfoDataModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["socialInfoDataModel"] = this.socialInfoDataModel ? this.socialInfoDataModel.toJSON() : <any>undefined;
        if (this.ethicsDataModel && this.ethicsDataModel.constructor === Array) {
            data["ethicsDataModel"] = [];
            for (let item of this.ethicsDataModel)
                data["ethicsDataModel"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Dto_SocialInfoDataModel {
        const json = this.toJSON();
        let result = new Dto_SocialInfoDataModel();
        result.init(json);
        return result;
    }
}

export interface IDto_SocialInfoDataModel {
    socialInfoDataModel: Dto_SocialInfo | undefined;
    ethicsDataModel: Dto_EthicsDataViewModel[] | undefined;
}

export class Dto_SocialInfo implements IDto_SocialInfo {
    yearOfSurvey: number | undefined;
    noOfHousehold: number | undefined;
    womenHeadedHouseHold: number | undefined;
    female: number | undefined;
    male: number | undefined;
    totalPopulation: number;
    majorSourceOfIncome: string;
    annualIncomePerFamily: number | undefined;
    annualIncomePerAgriculture: number | undefined;
    annualIncomePerOtherSrcs: number | undefined;
    literacyRate: number | undefined;
    femaleLiteracyRate: number | undefined;
    maleLiteracyRate: number | undefined;
    annualPopMigrationIn: number | undefined;
    annualPopMigrationOut: number | undefined;
    landOwners: number | undefined;
    landOwnersPercent: number | undefined;
    tenants: number | undefined;
    tenantsPercent: number | undefined;
    ownerWithTenants: number | undefined;
    ownerWithTenantsPercent: number | undefined;
    landless: number | undefined;
    landlessPercent: number | undefined;
    farmSizeSmall: number | undefined;
    farmSizeMedium: number | undefined;
    farmSizeLarge: number | undefined;
    farmSizeVeryLarge: number | undefined;
    farmSizeSmallPercent: number | undefined;
    farmSizeMediumPercent: number | undefined;
    farmSizeLargePercent: number | undefined;
    farmSizeVeryLargePercent: number | undefined;
    foodSufficiency: string | undefined;
    foodSufficiencMonth: number | undefined;
    projectId: string | undefined;
    averageFamilySize: number | undefined;
    averageAnnualIncomePerFamily: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_SocialInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.yearOfSurvey = data["yearOfSurvey"];
            this.noOfHousehold = data["noOfHousehold"];
            this.womenHeadedHouseHold = data["womenHeadedHouseHold"];
            this.female = data["female"];
            this.male = data["male"];
            this.totalPopulation = data["totalPopulation"];
            this.majorSourceOfIncome = data["majorSourceOfIncome"];
            this.annualIncomePerFamily = data["annualIncomePerFamily"];
            this.annualIncomePerAgriculture = data["annualIncomePerAgriculture"];
            this.annualIncomePerOtherSrcs = data["annualIncomePerOtherSrcs"];
            this.literacyRate = data["literacyRate"];
            this.femaleLiteracyRate = data["femaleLiteracyRate"];
            this.maleLiteracyRate = data["maleLiteracyRate"];
            this.annualPopMigrationIn = data["annualPopMigrationIn"];
            this.annualPopMigrationOut = data["annualPopMigrationOut"];
            this.landOwners = data["landOwners"];
            this.landOwnersPercent = data["landOwnersPercent"];
            this.tenants = data["tenants"];
            this.tenantsPercent = data["tenantsPercent"];
            this.ownerWithTenants = data["ownerWithTenants"];
            this.ownerWithTenantsPercent = data["ownerWithTenantsPercent"];
            this.landless = data["landless"];
            this.landlessPercent = data["landlessPercent"];
            this.farmSizeSmall = data["farmSizeSmall"];
            this.farmSizeMedium = data["farmSizeMedium"];
            this.farmSizeLarge = data["farmSizeLarge"];
            this.farmSizeVeryLarge = data["farmSizeVeryLarge"];
            this.farmSizeSmallPercent = data["farmSizeSmallPercent"];
            this.farmSizeMediumPercent = data["farmSizeMediumPercent"];
            this.farmSizeLargePercent = data["farmSizeLargePercent"];
            this.farmSizeVeryLargePercent = data["farmSizeVeryLargePercent"];
            this.foodSufficiency = data["foodSufficiency"];
            this.foodSufficiencMonth = data["foodSufficiencMonth"];
            this.projectId = data["projectId"];
            this.averageFamilySize = data["averageFamilySize"];
            this.averageAnnualIncomePerFamily = data["averageAnnualIncomePerFamily"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_SocialInfo {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_SocialInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["yearOfSurvey"] = this.yearOfSurvey;
        data["noOfHousehold"] = this.noOfHousehold;
        data["womenHeadedHouseHold"] = this.womenHeadedHouseHold;
        data["female"] = this.female;
        data["male"] = this.male;
        data["totalPopulation"] = this.totalPopulation;
        data["majorSourceOfIncome"] = this.majorSourceOfIncome;
        data["annualIncomePerFamily"] = this.annualIncomePerFamily;
        data["annualIncomePerAgriculture"] = this.annualIncomePerAgriculture;
        data["annualIncomePerOtherSrcs"] = this.annualIncomePerOtherSrcs;
        data["literacyRate"] = this.literacyRate;
        data["femaleLiteracyRate"] = this.femaleLiteracyRate;
        data["maleLiteracyRate"] = this.maleLiteracyRate;
        data["annualPopMigrationIn"] = this.annualPopMigrationIn;
        data["annualPopMigrationOut"] = this.annualPopMigrationOut;
        data["landOwners"] = this.landOwners;
        data["landOwnersPercent"] = this.landOwnersPercent;
        data["tenants"] = this.tenants;
        data["tenantsPercent"] = this.tenantsPercent;
        data["ownerWithTenants"] = this.ownerWithTenants;
        data["ownerWithTenantsPercent"] = this.ownerWithTenantsPercent;
        data["landless"] = this.landless;
        data["landlessPercent"] = this.landlessPercent;
        data["farmSizeSmall"] = this.farmSizeSmall;
        data["farmSizeMedium"] = this.farmSizeMedium;
        data["farmSizeLarge"] = this.farmSizeLarge;
        data["farmSizeVeryLarge"] = this.farmSizeVeryLarge;
        data["farmSizeSmallPercent"] = this.farmSizeSmallPercent;
        data["farmSizeMediumPercent"] = this.farmSizeMediumPercent;
        data["farmSizeLargePercent"] = this.farmSizeLargePercent;
        data["farmSizeVeryLargePercent"] = this.farmSizeVeryLargePercent;
        data["foodSufficiency"] = this.foodSufficiency;
        data["foodSufficiencMonth"] = this.foodSufficiencMonth;
        data["projectId"] = this.projectId;
        data["averageFamilySize"] = this.averageFamilySize;
        data["averageAnnualIncomePerFamily"] = this.averageAnnualIncomePerFamily;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_SocialInfo {
        const json = this.toJSON();
        let result = new Dto_SocialInfo();
        result.init(json);
        return result;
    }
}

export interface IDto_SocialInfo {
    yearOfSurvey: number | undefined;
    noOfHousehold: number | undefined;
    womenHeadedHouseHold: number | undefined;
    female: number | undefined;
    male: number | undefined;
    totalPopulation: number;
    majorSourceOfIncome: string;
    annualIncomePerFamily: number | undefined;
    annualIncomePerAgriculture: number | undefined;
    annualIncomePerOtherSrcs: number | undefined;
    literacyRate: number | undefined;
    femaleLiteracyRate: number | undefined;
    maleLiteracyRate: number | undefined;
    annualPopMigrationIn: number | undefined;
    annualPopMigrationOut: number | undefined;
    landOwners: number | undefined;
    landOwnersPercent: number | undefined;
    tenants: number | undefined;
    tenantsPercent: number | undefined;
    ownerWithTenants: number | undefined;
    ownerWithTenantsPercent: number | undefined;
    landless: number | undefined;
    landlessPercent: number | undefined;
    farmSizeSmall: number | undefined;
    farmSizeMedium: number | undefined;
    farmSizeLarge: number | undefined;
    farmSizeVeryLarge: number | undefined;
    farmSizeSmallPercent: number | undefined;
    farmSizeMediumPercent: number | undefined;
    farmSizeLargePercent: number | undefined;
    farmSizeVeryLargePercent: number | undefined;
    foodSufficiency: string | undefined;
    foodSufficiencMonth: number | undefined;
    projectId: string | undefined;
    averageFamilySize: number | undefined;
    averageAnnualIncomePerFamily: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_SocialInfo implements IPagedResultDtoOfDto_SocialInfo {
    totalCount: number | undefined;
    items: Dto_SocialInfo[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_SocialInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_SocialInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_SocialInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_SocialInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_SocialInfo {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_SocialInfo();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_SocialInfo {
    totalCount: number | undefined;
    items: Dto_SocialInfo[] | undefined;
}

export class Dto_Spur implements IDto_Spur {
    no: number | undefined;
    locationChainage: number | undefined;
    spacing: number | undefined;
    hfl: number | undefined;
    lwl: number | undefined;
    types: string | undefined;
    materails: string | undefined;
    conditions: string | undefined;
    designTopWidth: number | undefined;
    designFreeboard: number | undefined;
    slideSlope1: string | undefined;
    lengthOfLaunchingApron: number | undefined;
    thicknessOfPitching: number | undefined;
    thicknessOfFilter: number | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_Spur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.no = data["no"];
            this.locationChainage = data["locationChainage"];
            this.spacing = data["spacing"];
            this.hfl = data["hfl"];
            this.lwl = data["lwl"];
            this.types = data["types"];
            this.materails = data["materails"];
            this.conditions = data["conditions"];
            this.designTopWidth = data["designTopWidth"];
            this.designFreeboard = data["designFreeboard"];
            this.slideSlope1 = data["slideSlope1"];
            this.lengthOfLaunchingApron = data["lengthOfLaunchingApron"];
            this.thicknessOfPitching = data["thicknessOfPitching"];
            this.thicknessOfFilter = data["thicknessOfFilter"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_Spur {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_Spur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["no"] = this.no;
        data["locationChainage"] = this.locationChainage;
        data["spacing"] = this.spacing;
        data["hfl"] = this.hfl;
        data["lwl"] = this.lwl;
        data["types"] = this.types;
        data["materails"] = this.materails;
        data["conditions"] = this.conditions;
        data["designTopWidth"] = this.designTopWidth;
        data["designFreeboard"] = this.designFreeboard;
        data["slideSlope1"] = this.slideSlope1;
        data["lengthOfLaunchingApron"] = this.lengthOfLaunchingApron;
        data["thicknessOfPitching"] = this.thicknessOfPitching;
        data["thicknessOfFilter"] = this.thicknessOfFilter;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_Spur {
        const json = this.toJSON();
        let result = new Dto_Spur();
        result.init(json);
        return result;
    }
}

export interface IDto_Spur {
    no: number | undefined;
    locationChainage: number | undefined;
    spacing: number | undefined;
    hfl: number | undefined;
    lwl: number | undefined;
    types: string | undefined;
    materails: string | undefined;
    conditions: string | undefined;
    designTopWidth: number | undefined;
    designFreeboard: number | undefined;
    slideSlope1: string | undefined;
    lengthOfLaunchingApron: number | undefined;
    thicknessOfPitching: number | undefined;
    thicknessOfFilter: number | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_Spur implements IPagedResultDtoOfDto_Spur {
    totalCount: number | undefined;
    items: Dto_Spur[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_Spur) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_Spur.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_Spur {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_Spur();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_Spur {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_Spur();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_Spur {
    totalCount: number | undefined;
    items: Dto_Spur[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;
}

export class Dto_TertiaryCanal implements IDto_TertiaryCanal {
    name: string | undefined;
    gca: number | undefined;
    cca: number | undefined;
    unlinedTypeCanalLength: number | undefined;
    linedTypeCanalLength: number | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    canalStructure: string | undefined;
    secondaryCanalId: number | undefined;
    id: number | undefined;

    constructor(data?: IDto_TertiaryCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.gca = data["gca"];
            this.cca = data["cca"];
            this.unlinedTypeCanalLength = data["unlinedTypeCanalLength"];
            this.linedTypeCanalLength = data["linedTypeCanalLength"];
            this.totalLength = data["totalLength"];
            this.designDischarge = data["designDischarge"];
            this.canalStructure = data["canalStructure"];
            this.secondaryCanalId = data["secondaryCanalId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_TertiaryCanal {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_TertiaryCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["gca"] = this.gca;
        data["cca"] = this.cca;
        data["unlinedTypeCanalLength"] = this.unlinedTypeCanalLength;
        data["linedTypeCanalLength"] = this.linedTypeCanalLength;
        data["totalLength"] = this.totalLength;
        data["designDischarge"] = this.designDischarge;
        data["canalStructure"] = this.canalStructure;
        data["secondaryCanalId"] = this.secondaryCanalId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_TertiaryCanal {
        const json = this.toJSON();
        let result = new Dto_TertiaryCanal();
        result.init(json);
        return result;
    }
}

export interface IDto_TertiaryCanal {
    name: string | undefined;
    gca: number | undefined;
    cca: number | undefined;
    unlinedTypeCanalLength: number | undefined;
    linedTypeCanalLength: number | undefined;
    totalLength: number | undefined;
    designDischarge: number | undefined;
    canalStructure: string | undefined;
    secondaryCanalId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_TertiaryCanal implements IPagedResultDtoOfDto_TertiaryCanal {
    totalCount: number | undefined;
    items: Dto_TertiaryCanal[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_TertiaryCanal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_TertiaryCanal.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_TertiaryCanal {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_TertiaryCanal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_TertiaryCanal {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_TertiaryCanal();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_TertiaryCanal {
    totalCount: number | undefined;
    items: Dto_TertiaryCanal[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.adminPassword = data["adminPassword"];
            this.userId = data["userId"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;
}

export class ListResultDtoOfUserDto implements IListResultDtoOfUserDto {
    items: UserDto[] | undefined;

    constructor(data?: IListResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUserDto {
    items: UserDto[] | undefined;
}

export class Dto_UserProject implements IDto_UserProject {
    projectId: string | undefined;
    userId: number | undefined;
    id: string | undefined;

    constructor(data?: IDto_UserProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.projectId = data["projectId"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_UserProject {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_UserProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_UserProject {
        const json = this.toJSON();
        let result = new Dto_UserProject();
        result.init(json);
        return result;
    }
}

export interface IDto_UserProject {
    projectId: string | undefined;
    userId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfDto_UserProject implements IPagedResultDtoOfDto_UserProject {
    totalCount: number | undefined;
    items: Dto_UserProject[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_UserProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_UserProject.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_UserProject {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_UserProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_UserProject {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_UserProject();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_UserProject {
    totalCount: number | undefined;
    items: Dto_UserProject[] | undefined;
}

export class Dto_WaterInducedDisasterModel implements IDto_WaterInducedDisasterModel {
    averageRiverWidth: number | undefined;
    averageRiverSlope1: number | undefined;
    protectedArea: number | undefined;
    reclaimedArea: number | undefined;
    inlineStructure: string | undefined;
    inlineStructureOthers: string | undefined;
    lateralStructure: string | undefined;
    lateralStructureOthers: string | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_WaterInducedDisasterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.averageRiverWidth = data["averageRiverWidth"];
            this.averageRiverSlope1 = data["averageRiverSlope1"];
            this.protectedArea = data["protectedArea"];
            this.reclaimedArea = data["reclaimedArea"];
            this.inlineStructure = data["inlineStructure"];
            this.inlineStructureOthers = data["inlineStructureOthers"];
            this.lateralStructure = data["lateralStructure"];
            this.lateralStructureOthers = data["lateralStructureOthers"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_WaterInducedDisasterModel {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_WaterInducedDisasterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["averageRiverWidth"] = this.averageRiverWidth;
        data["averageRiverSlope1"] = this.averageRiverSlope1;
        data["protectedArea"] = this.protectedArea;
        data["reclaimedArea"] = this.reclaimedArea;
        data["inlineStructure"] = this.inlineStructure;
        data["inlineStructureOthers"] = this.inlineStructureOthers;
        data["lateralStructure"] = this.lateralStructure;
        data["lateralStructureOthers"] = this.lateralStructureOthers;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_WaterInducedDisasterModel {
        const json = this.toJSON();
        let result = new Dto_WaterInducedDisasterModel();
        result.init(json);
        return result;
    }
}

export interface IDto_WaterInducedDisasterModel {
    averageRiverWidth: number | undefined;
    averageRiverSlope1: number | undefined;
    protectedArea: number | undefined;
    reclaimedArea: number | undefined;
    inlineStructure: string | undefined;
    inlineStructureOthers: string | undefined;
    lateralStructure: string | undefined;
    lateralStructureOthers: string | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_WaterInducedDisasterModel implements IPagedResultDtoOfDto_WaterInducedDisasterModel {
    totalCount: number | undefined;
    items: Dto_WaterInducedDisasterModel[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_WaterInducedDisasterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_WaterInducedDisasterModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_WaterInducedDisasterModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_WaterInducedDisasterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_WaterInducedDisasterModel {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_WaterInducedDisasterModel();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_WaterInducedDisasterModel {
    totalCount: number | undefined;
    items: Dto_WaterInducedDisasterModel[] | undefined;
}

export class Dto_WUAInfo implements IDto_WUAInfo {
    name: string | undefined;
    noOfWUAMembers: number | undefined;
    noOffemaleMembers: number | undefined;
    wuaRegistrationDate: moment.Moment | undefined;
    wuaRenewdUpToDate: moment.Moment | undefined;
    registrationPlace: string | undefined;
    presidentName: string | undefined;
    contactNumber: string | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_WUAInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.noOfWUAMembers = data["noOfWUAMembers"];
            this.noOffemaleMembers = data["noOffemaleMembers"];
            this.wuaRegistrationDate = data["wuaRegistrationDate"] ? moment(data["wuaRegistrationDate"].toString()) : <any>undefined;
            this.wuaRenewdUpToDate = data["wuaRenewdUpToDate"] ? moment(data["wuaRenewdUpToDate"].toString()) : <any>undefined;
            this.registrationPlace = data["registrationPlace"];
            this.presidentName = data["presidentName"];
            this.contactNumber = data["contactNumber"];
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_WUAInfo {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_WUAInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["noOfWUAMembers"] = this.noOfWUAMembers;
        data["noOffemaleMembers"] = this.noOffemaleMembers;
        data["wuaRegistrationDate"] = this.wuaRegistrationDate ? this.wuaRegistrationDate.toISOString() : <any>undefined;
        data["wuaRenewdUpToDate"] = this.wuaRenewdUpToDate ? this.wuaRenewdUpToDate.toISOString() : <any>undefined;
        data["registrationPlace"] = this.registrationPlace;
        data["presidentName"] = this.presidentName;
        data["contactNumber"] = this.contactNumber;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_WUAInfo {
        const json = this.toJSON();
        let result = new Dto_WUAInfo();
        result.init(json);
        return result;
    }
}

export interface IDto_WUAInfo {
    name: string | undefined;
    noOfWUAMembers: number | undefined;
    noOffemaleMembers: number | undefined;
    wuaRegistrationDate: moment.Moment | undefined;
    wuaRenewdUpToDate: moment.Moment | undefined;
    registrationPlace: string | undefined;
    presidentName: string | undefined;
    contactNumber: string | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_WUAInfo implements IPagedResultDtoOfDto_WUAInfo {
    totalCount: number | undefined;
    items: Dto_WUAInfo[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_WUAInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_WUAInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_WUAInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_WUAInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_WUAInfo {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_WUAInfo();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_WUAInfo {
    totalCount: number | undefined;
    items: Dto_WUAInfo[] | undefined;
}

export class Dto_WUATraining implements IDto_WUATraining {
    trainingName: string | undefined;
    noOfParticipants: number | undefined;
    trainingPeriod: number | undefined;
    noOfFemaleParticipant: number | undefined;
    trainingDate: moment.Moment | undefined;
    projectId: string | undefined;
    id: number | undefined;

    constructor(data?: IDto_WUATraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trainingName = data["trainingName"];
            this.noOfParticipants = data["noOfParticipants"];
            this.trainingPeriod = data["trainingPeriod"];
            this.noOfFemaleParticipant = data["noOfFemaleParticipant"];
            this.trainingDate = data["trainingDate"] ? moment(data["trainingDate"].toString()) : <any>undefined;
            this.projectId = data["projectId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Dto_WUATraining {
        data = typeof data === 'object' ? data : {};
        let result = new Dto_WUATraining();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingName"] = this.trainingName;
        data["noOfParticipants"] = this.noOfParticipants;
        data["trainingPeriod"] = this.trainingPeriod;
        data["noOfFemaleParticipant"] = this.noOfFemaleParticipant;
        data["trainingDate"] = this.trainingDate ? this.trainingDate.toISOString() : <any>undefined;
        data["projectId"] = this.projectId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Dto_WUATraining {
        const json = this.toJSON();
        let result = new Dto_WUATraining();
        result.init(json);
        return result;
    }
}

export interface IDto_WUATraining {
    trainingName: string | undefined;
    noOfParticipants: number | undefined;
    trainingPeriod: number | undefined;
    noOfFemaleParticipant: number | undefined;
    trainingDate: moment.Moment | undefined;
    projectId: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfDto_WUATraining implements IPagedResultDtoOfDto_WUATraining {
    totalCount: number | undefined;
    items: Dto_WUATraining[] | undefined;

    constructor(data?: IPagedResultDtoOfDto_WUATraining) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Dto_WUATraining.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDto_WUATraining {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDto_WUATraining();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDto_WUATraining {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDto_WUATraining();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDto_WUATraining {
    totalCount: number | undefined;
    items: Dto_WUATraining[] | undefined;
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}